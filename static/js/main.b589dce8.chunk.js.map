{"version":3,"sources":["util/tubemap.js","enums.js","components/DataPositionFormRow.js","components/MountedDataFormRow.js","components/FileUploadFormRow.js","components/ExampleSelectButtons.js","components/HeaderForm.js","components/TubeMap.js","components/TubeMapContainer.js","components/RadioRow.js","components/CustomizationAccordion.js","App.js","index.js"],"names":["svgID","svg","zoom","nodes","tracks","reads","numberOfNodes","numberOfTracks","nodeMap","nodesPerOrder","maxOrder","trackForRuler","bed","dataOriginTypes","DEBUG","greys","blues","reds","plainColors","lightColors","fonts","haplotypeColors","forwardReadColors","reverseReadColors","exonColors","inputNodes","inputTracks","inputReads","assignments","extraLeft","extraRight","config","mergeNodesFlag","transparentNodesFlag","clickableNodesFlag","showExonsFlag","colorScheme","nodeWidthOption","showReads","showSoftClips","hideLegendFlag","colorReadsByMappingQuality","mappingQualityCutoff","trackRectangles","trackCurves","trackCorners","trackVerticalRectangles","trackRectanglesStep3","maxYCoordinate","minYCoordinate","maxXCoordinate","create","params","d3","JSON","parse","stringify","clickableNodes","hideLegend","createTubeMap","drawLegend","isReverse","nodeName","s","String","length","charAt","forward","substr","reverse","straightenTrack","index","i","j","currentSequence","nodesToInvert","sequence","indexOf","push","forEach","node","name","seq","split","join","setColorSet","trackType","colorSet","setNodeWidthOption","value","undefined","selectAll","remove","getColorSet","filter","read","is_secondary","mapping_quality","hasOwnProperty","type","hidden","splice","generateNodeMap","generateTrackIndexSequences","generateNodeWidth","generateNodeSuccessors","generateNodeOrder","reverseReversedReads","nodeName2","tracksAndReads","pred","succ","Set","concat","track","get","add","Array","from","sortedNodes","slice","sort","compareNodesByOrder","mergeOffset","Map","mergeOrigin","predecessor","mergeableWithPred","set","sequenceLength","firstNodeOffset","finalNodeCoverLength","mergeableWithSucc","sequenceNew","mismatches","mismatch","pos","donor","width","mergeNodes","indexSequence","nodeIndex","Math","abs","id","degree","max","order","getMaxOrder","allAreFour","round","log","freq","calculateTrackWidth","segmentNumber","currentNodeIndex","currentNodeIsForward","currentNode","previousNode","previousNodeIsForward","prevSegmentPerOrderPerTrack","isPositive","n","trackNo","path","lane","isForward","addToAssignment","generateSingleLaneAssignment","generateLaneAssignment","nodeStart","nodeEnd","feature","line","start","end","continue","features","addTrackFeatures","currentX","nextX","currentOrder","extra","leftSideEdges","rightSideEdges","calculateExtraSpace","x","pixelWidth","generateNodeXCoords","orderY","setMapToMax","y","contentHeight","step","generateReadOnlyNodeAttributes","generateBasicPathsForReads","incomingReads","outgoingReads","internalReads","idx","element","pathIdx","compareReadIncomingSegmentsByComingFrom","currentY","occupiedUntil","readElement","setOccupiedUntil","maxY","compareReadOutgoingSegmentsByGoingTo","occupiedFrom","has","incReadElementIndices","incRead","incReadPathElement","compareInternalReads","readIdx","currentRead","heightIncrease","adjustBy","assignmentNode","aNode","trackID","segmentID","adjustVertically3","bottomY","calculateBottomY","elementsWithoutNode","readIndex","pathIndex","previousY","compareNoNodeReadsByPreviousY","segment","placeReads","xStart","xEnd","yStart","yEnd","trackColor","highlight","dummy","reversalFlag","orderStartX","orderEndX","generateTrackColor","getXCoordinateOfBaseWithinNode","getReadXStart","createFeatureRectangle","min","color","laneChange","generateForwardToReverse","generateReverseToForward","getReadXEnd","generateSVGShapesFromPath","parentElement","document","getElementById","substring","parentNode","zoomed","transform","k","attr","svg2","clientWidth","offsetWidth","minZoom","extent","scaleExtent","translateExtent","on","call","append","containerWidth","xOffset","select","translate","alignSVG","defs","pattern","attrs","height","patternUnits","patternTransform","fill","defineSVGPatterns","drawTrackRectangles","drawTrackCurves","drawReversalsByColor","dNodes","allNodes","removeUnusedNodes","d","data","enter","nodeMouseOver","nodeMouseOut","nodeDoubleClick","style","text","drawNodes","drawLabels","rulerTrackIndex","rulerTrack","markingInterval","markingClearance","ticks","indexOfFirstBaseInNode","indexOfFirstBase","nextUnmarkedIndex","currentNodeIsReverse","alreadyMarkedNode","indexIntoVisitToMark","offsetIntoNodeForward","xCoordOfMarking","x1","separatedTicks","tick","sequencePosition","xCoordinate","drawRuler","trackIdx","mm","nodeY","insertionMouseOver","insertionMouseOut","drawInsertion","x2","deletionMouseOver","deletionMouseOut","drawDeletion","substitutionMouseOver","substitutionMouseOut","drawSubstitution","map","key","a","b","segmentA","segmentB","pathIndexA","pathIndexB","nodeA","nodeB","beginDiff","pathA","pathB","idxA","idxB","is_reverse","nodeWidth","getReverseComplement","temp","seqLength","result","tracksOrReads","zoomBy","zoomFactor","translateK","translateX","translateY","transition","duration","scale","current","follower","successors","predecessors","generateNodeOrderOfSingleTrack","forwardOrder","backwardOrder","minOrder","increaseOrderForAllNodes","generateNodeOrderTrackBeginning","increment","anchorIndex","modifiedSequence","rightIndex","leftIndex","uninvert","increaseOrderForSuccessors","isSuccessor","first","second","visited","stack","pop","childIndex","amount","startingNode","tabuNode","newOrder","increasedOrders","queue","shift","successor","compareToFromSame","assignment","currentLane","potentialAdjustmentValues","prevNameIsNull","prevTrack","idealLane","idealY","getIdealLanesAndCoords","compareByIdealLane","topLane","verticalAdjustment","minAdjustmentCost","Number","MAX_SAFE_INTEGER","moveBy","getVerticalAdjustmentCost","adjustVertically","colorSetName","base","nodeLeftX","nodeRightX","nodeXStart","nodeXEnd","rectXStart","c","co","featureXStart","featureXEnd","currentHighlight","trackWidth","yTop","yBottom","corners","rectangles","rect","filterObjectByAttribute","trackMouseOver","trackMouseOut","trackDoubleClick","drawTrackCorners","attribute","item","compareCurvesByLineChanges","myTrackCurves","curve","xMiddle","content","listeners","innerHTML","addEventListener","changeTrackVisibility","this","each","unshift","moveTrackToFirstPosition","nodeID","click","vgExtractNodes","vg","getComputedTextLength","vgExtractTracks","mapping","position","node_id","vgExtractReads","myNodes","myTracks","myReads","extracted","nodeNames","firstIndex","lastIndex","edit","offset","toString","parseInt","posWithinNode","from_length","finalNodeEdit","predecessorIndex","successorIndex","DataPositionFormRow","handleZoomIn","tubeMap","handleZoomOut","handleDownloadButton","svgN","svgData","XMLSerializer","serializeToString","svgBlob","Blob","svgUrl","URL","createObjectURL","downloadLink","createElement","href","download","body","appendChild","removeChild","Form","inline","Label","className","for","Input","size","props","onChange","handleInputChange","distance","byNode","uploadInProgress","Button","onClick","handleGoButton","disabled","handleGoLeft","icon","faStepBackward","faSearchPlus","faSearchMinus","handleGoRight","faStepForward","Component","MountedDataFormRow","xgFileDropdownOptions","xgSelectOptions","fileName","gbwtFileDropdownOptions","gbwtSelectOptions","gamFileDropdownOptions","gamSelectOptions","pathDropdownOptions","pathSelectOptions","pathName","Fragment","xgSelect","gbwtSelect","gamSelect","pathSelect","MAX_UPLOAD_SIZE","FileUploadFormRow","onXgFileChange","file","xgFileInput","files","resetPathNames","handleFileUpload","showFileSizeAlert","setUploadInProgress","formData","FormData","xhr","XMLHttpRequest","responseType","onreadystatechange","readyState","status","response","getPathNames","open","apiUrl","send","onGbwtFileChange","gbwtFileInput","onGamFileChange","gamFileInput","React","createRef","accept","innerRef","ExampleSelectButtons","handleClick","dataOrigin","haploColor","readColor","setDataOrigin","setColorSetting","DATA_SOURCES","dataTypes","HeaderForm","state","xgFile","gbwtFile","gamFile","anchorTrackName","dataPath","dataType","fileSizeAlert","getMountedFilenames","fetch","method","headers","json","xgFiles","gbwtFiles","gamIndices","setState","includes","console","isUploadedFile","pathNames","handleDataSourceChange","event","target","ds","useMountedPath","defaultPosition","fetchParams","setFetchParams","fileType","val","setUpWebsocket","ws","WebSocket","replace","onmessage","message","onclose","setTimeout","onerror","close","dataSourceDropdownOptions","mountedFilesFlag","uploadFilesFlag","examplesFlag","Container","fluid","Row","Col","md","src","alt","Alert","isOpen","toggle","TubeMap","TubeMapContainer","isLoading","error","getRemoteTubeMapData","graph","gam","getExampleData","inputTracks1","inputTracks2","inputTracks3","inputTracks4","inputTracks5","k3138","readsFromStringToArray","demoReads","readsString","lines","prevProps","colorMap","RadioRow","colorRadios","keyColor","valueColor","xs","FormGroup","check","checked","row","sm","rowHeading","VisualizationOptions","isOpenLegend","isOpenVisualizationOptions","toggleLegend","e","preventDefault","toggleVisOptions","handleMappingQualityCutoffChange","visOptions","toggleFlag","mappingQualityOptions","keys","Card","CardHeader","Collapse","CardBody","removeRedundantNodes","compressedView","transparentNodes","App","toggleVisOptionFlag","flagName","CustomizationAccordion","defaultProps","BACKEND_URL","window","location","host","ReactDOM","render"],"mappings":"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","file":"static/js/main.b589dce8.chunk.js","sourcesContent":["/* eslint no-param-reassign: \"off\" */\n/* eslint no-lonely-if: \"off\" */\n/* eslint no-prototype-builtins: \"off\" */\n/* eslint no-console: \"off\" */\n/* eslint no-continue: \"off\" */\n\n/* eslint max-len: \"off\" */\n/* eslint no-loop-func: \"off\" */\n/* eslint no-unused-vars: \"off\" */\n/* eslint no-return-assign: \"off\" */\nimport * as d3 from 'd3';\nimport 'd3-selection-multi';\n\nconst DEBUG = false;\n\nconst greys = [\n  '#d9d9d9',\n  '#bdbdbd',\n  '#969696',\n  '#737373',\n  '#525252',\n  '#252525',\n  '#000000'\n];\n\nconst blues = [\n  '#c6dbef',\n  '#9ecae1',\n  '#6baed6',\n  '#4292c6',\n  '#2171b5',\n  '#08519c',\n  '#08306b'\n];\n\nconst reds = [\n  '#fcbba1',\n  '#fc9272',\n  '#fb6a4a',\n  '#ef3b2c',\n  '#cb181d',\n  '#a50f15',\n  '#67000d'\n];\n\n// d3 category10\nconst plainColors = [\n  '#1f77b4',\n  '#ff7f0e',\n  '#2ca02c',\n  '#d62728',\n  '#9467bd',\n  '#8c564b',\n  '#e377c2',\n  '#7f7f7f',\n  '#bcbd22',\n  '#17becf'\n];\n\n// d3 category10\nconst lightColors = [\n  '#ABCCE3',\n  '#FFCFA5',\n  '#B0DBB0',\n  '#F0AEAE',\n  '#D7C6E6',\n  '#C6ABA5',\n  '#F4CCE8',\n  '#CFCFCF',\n  '#E6E6AC',\n  '#A8E7ED'\n];\n\n// Font stack we will use in the SVG\n// We start with Courier New because it exists a lot more places than\n// \"Courier\", and because tools like Inkscape can't interpret the text properly\n// if they don't have the first font named here.\nconst fonts = '\"Courier New\", \"Courier\", \"Lucida Console\", monospace';\n\nlet haplotypeColors = [];\nlet forwardReadColors = [];\nlet reverseReadColors = [];\nlet exonColors = [];\n\nlet svgID; // the (html-tag) ID of the svg\nlet svg; // the svg\nexport let zoom; // eslint-disable-line import/no-mutable-exports\nlet inputNodes = [];\nlet inputTracks = [];\nlet inputReads = [];\nlet nodes;\nlet tracks;\nlet reads;\nlet numberOfNodes;\nlet numberOfTracks;\nlet nodeMap; // maps node names to node indices\nlet nodesPerOrder;\nlet assignments = []; // contains info about lane assignments sorted by order\nlet extraLeft = []; // info whether nodes have to be moved further apart because of multiple 180 directional changes at the same horizontal order\nlet extraRight = []; // info whether nodes have to be moved further apart because of multiple 180 directional changes at the same horizontal order\nlet maxOrder; // horizontal order of the rightmost node\n\nconst config = {\n  mergeNodesFlag: true,\n  transparentNodesFlag: false,\n  clickableNodesFlag: false,\n  showExonsFlag: false,\n  colorScheme: 0,\n  // Options for the width of sequence nodes:\n  // 0...scale node width linear with number of bases within node\n  // 1...scale node width with log2 of number of bases within node\n  // 2...scale node width with log10 of number of bases within node\n  nodeWidthOption: 0,\n  showReads: true,\n  showSoftClips: true,\n  haplotypeColors: 'greys',\n  forwardReadColors: 'reds',\n  reverseReadColors: 'blues',\n  exonColors: 'lightColors',\n  hideLegendFlag: false,\n  colorReadsByMappingQuality: false,\n  mappingQualityCutoff: 0\n};\n\n// variables for storing info which can be directly translated into drawing instructions\nlet trackRectangles = [];\nlet trackCurves = [];\nlet trackCorners = [];\nlet trackVerticalRectangles = []; // stored separately from horizontal rectangles. This allows drawing them in a separate step -> avoids issues with wrong overlapping\nlet trackRectanglesStep3 = [];\n\nlet maxYCoordinate = 0;\nlet minYCoordinate = 0;\nlet maxXCoordinate = 0;\nlet trackForRuler;\n\nlet bed;\n\n// main function to call from outside\n// which starts the process of creating a tube map visualization\nexport function create(params) {\n  // mandatory parameters: svgID (really a selector, but must be an ID selector), nodes, tracks\n  // optional parameters: bed, clickableNodes, reads, showLegend\n  svgID = params.svgID;\n  svg = d3.select(params.svgID);\n  inputNodes = JSON.parse(JSON.stringify(params.nodes)); // deep copy\n  inputTracks = JSON.parse(JSON.stringify(params.tracks)); // deep copy\n  inputReads = params.reads || null;\n  bed = params.bed || null;\n  config.clickableNodesFlag = params.clickableNodes || false;\n  config.hideLegendFlag = params.hideLegend || false;\n  const tr = createTubeMap();\n  if (!config.hideLegendFlag) drawLegend(tr);\n}\n\n// Return true if the given name names a reverse strand node, and false otherwise.\nfunction isReverse(nodeName) {\n  const s = String(nodeName);\n  return (s.length >= 1 && s.charAt(0) === '-');\n}\n\n// Get the forward version of a node name, which may be either forward or backward (negative)\nfunction forward(nodeName) {\n  if (isReverse(nodeName)) {\n    // It looks like a negative value.\n    // Make sure it's a string and cut off the -.\n    return String(nodeName).substr(1);\n  } else {\n    // It's forward.\n    return nodeName;\n  }\n}\n\n// Get the reverse version of a node name, which may be either forward or backward (negative)\nfunction reverse(nodeName) {\n  if (isReverse(nodeName)) {\n    return nodeName;\n  } else {\n    return `-${nodeName}`;\n  }\n}\n\n// Get the opposite orientation node name for the given node.\nfunction flip(nodeName) {\n  if (isReverse(nodeName)) {\n    return forward(nodeName);\n  } else {\n    return reverse(nodeName);\n  }\n}\n\n// moves a specific track to the top\nfunction moveTrackToFirstPosition(index) {\n  inputTracks.unshift(inputTracks[index]); // add element to beginning\n  inputTracks.splice(index + 1, 1); // remove 1 element from the middle\n  straightenTrack(0);\n}\n\n// straighten track given by index by inverting inverted nodes\n// only keep them inverted if this single track runs thrugh them in both directions\nfunction straightenTrack(index) {\n  let i;\n  let j;\n  const nodesToInvert = [];\n  let currentSequence;\n  let nodeName;\n\n  // find out which nodes should be inverted\n  currentSequence = inputTracks[index].sequence;\n  for (i = 0; i < currentSequence.length; i += 1) {\n    if (isReverse(currentSequence[i])) {\n      nodeName = forward(currentSequence[i]);\n      if (\n        currentSequence.indexOf(nodeName) === -1 ||\n        currentSequence.indexOf(nodeName) > i\n      ) {\n        // only if this inverted node is no repeat\n        nodesToInvert.push(nodeName);\n      }\n    }\n  }\n\n  // invert nodes in the tracks' sequence\n  for (i = 0; i < inputTracks.length; i += 1) {\n    currentSequence = inputTracks[i].sequence;\n    for (j = 0; j < currentSequence.length; j += 1) {\n      if (!isReverse(currentSequence[j])) {\n        if (nodesToInvert.indexOf(currentSequence[j]) !== -1) {\n          currentSequence[j] = reverse(currentSequence[j]);\n        }\n      } else if (nodesToInvert.indexOf(forward(currentSequence[j])) !== -1) {\n        currentSequence[j] = forward(currentSequence[j]);\n      }\n    }\n  }\n\n  // invert the sequence within the nodes\n  inputNodes.forEach(node => {\n    if (nodesToInvert.indexOf(node.name) !== -1) {\n      node.seq = node.seq\n        .split('')\n        .reverse()\n        .join('');\n    }\n  });\n}\n\nexport function changeTrackVisibility(trackID) {\n  let i = 0;\n  while (i < inputTracks.length && inputTracks[i].id !== trackID) i += 1;\n  if (i < inputTracks.length) {\n    if (inputTracks[i].hasOwnProperty('hidden')) {\n      inputTracks[i].hidden = !inputTracks[i].hidden;\n    } else {\n      inputTracks[i].hidden = true;\n    }\n  }\n  createTubeMap();\n}\n\nexport function changeExonVisibility() {\n  config.showExonsFlag = !config.showExonsFlag;\n  createTubeMap();\n}\n\n// sets the flag for whether redundant nodes should be automatically removed or not\nexport function setMergeNodesFlag(value) {\n  if (config.mergeNodesFlag !== value) {\n    config.mergeNodesFlag = value;\n    svg = d3.select(svgID);\n    createTubeMap();\n  }\n}\n\n// sets the flag for whether nodes should be fully transparent or not\nexport function setTransparentNodesFlag(value) {\n  if (config.transparentNodesFlag !== value) {\n    config.transparentNodesFlag = value;\n    svg = d3.select(svgID);\n    createTubeMap();\n  }\n}\n\n// sets the flag for whether read soft clips should be displayed or not\nexport function setSoftClipsFlag(value) {\n  if (config.showSoftClips !== value) {\n    config.showSoftClips = value;\n    svg = d3.select(svgID);\n    createTubeMap();\n  }\n}\n\n// sets the flag for whether reads should be displayed or not\nexport function setShowReadsFlag(value) {\n  if (config.showReads !== value) {\n    config.showReads = value;\n    svg = d3.select(svgID);\n    createTubeMap();\n  }\n}\n\nexport function setColorSet(trackType, colorSet) {\n  if (config[trackType] !== colorSet) {\n    config[trackType] = colorSet;\n    const tr = createTubeMap();\n    if (!config.hideLegendFlag) drawLegend(tr);\n  }\n}\n\n// sets which option should be used for calculating the node width from its sequence length\nexport function setNodeWidthOption(value) {\n  if (value === 0 || value === 1 || value === 2) {\n    if (config.nodeWidthOption !== value) {\n      config.nodeWidthOption = value;\n      if (svg !== undefined) {\n        svg = d3.select(svgID);\n        createTubeMap();\n      }\n    }\n  }\n}\n\nexport function setColorReadsByMappingQualityFlag(value) {\n  if (config.colorReadsByMappingQuality !== value) {\n    config.colorReadsByMappingQuality = value;\n    svg = d3.select(svgID);\n    createTubeMap();\n  }\n}\n\nexport function setMappingQualityCutoff(value) {\n  if (config.mappingQualityCutoff !== value) {\n    config.mappingQualityCutoff = value;\n    if (svg !== undefined) {\n      svg = d3.select(svgID);\n      createTubeMap();\n    }\n  }\n}\n\n// main\nfunction createTubeMap() {\n  trackRectangles = [];\n  trackCurves = [];\n  trackCorners = [];\n  trackVerticalRectangles = [];\n  trackRectanglesStep3 = [];\n  assignments = [];\n  extraLeft = [];\n  extraRight = [];\n  maxYCoordinate = 0;\n  minYCoordinate = 0;\n  maxXCoordinate = 0;\n  trackForRuler = undefined;\n  svg = d3.select(svgID);\n  svg.selectAll('*').remove(); // clear svg for (re-)drawing\n\n  // early exit is necessary when visualization options such as colors are\n  // changed before any graph has been rendered\n  if (inputNodes.length === 0 || inputTracks.length === 0) return;\n\n  straightenTrack(0);\n  nodes = JSON.parse(JSON.stringify(inputNodes)); // deep copy (can add stuff to copy and leave original unchanged)\n  tracks = JSON.parse(JSON.stringify(inputTracks));\n  reads = JSON.parse(JSON.stringify(inputReads));\n\n  assignColorSets();\n  reads = filterReads(reads);\n\n  for (let i = tracks.length - 1; i >= 0; i -= 1) {\n    if (!tracks[i].hasOwnProperty('type')) {\n      // TODO: maybe remove \"haplo\"-property?\n      tracks[i].type = 'haplo';\n    }\n    if (tracks[i].hasOwnProperty('hidden')) {\n      if (tracks[i].hidden === true) {\n        tracks.splice(i, 1);\n      }\n    }\n    if (tracks[i] && tracks[i].hasOwnProperty('indexOfFirstBase')) {\n      trackForRuler = tracks[i].name;\n    }\n  }\n  if (tracks.length === 0) return;\n\n  nodeMap = generateNodeMap(nodes);\n  generateTrackIndexSequences(tracks);\n  if (reads && config.showReads) generateTrackIndexSequences(reads);\n  generateNodeWidth();\n\n  if (config.mergeNodesFlag) {\n    generateNodeSuccessors(); // requires indexSequence\n    generateNodeOrder(); // requires successors\n    if (reads && config.showReads) reverseReversedReads();\n    mergeNodes();\n    nodeMap = generateNodeMap(nodes);\n    generateNodeWidth();\n    generateTrackIndexSequences(tracks);\n    if (reads && config.showReads) generateTrackIndexSequences(reads);\n  }\n\n  numberOfNodes = nodes.length;\n  numberOfTracks = tracks.length;\n  generateNodeSuccessors();\n  generateNodeDegree();\n  if (DEBUG) console.log(`${numberOfNodes} nodes.`);\n  generateNodeOrder();\n  maxOrder = getMaxOrder();\n\n  // can cause problems when there is a reversed single track node\n  // OTOH, can solve problems with complex inversion patterns\n  // switchNodeOrientation();\n  // generateNodeOrder(nodes, tracks);\n  // maxOrder = getMaxOrder();\n\n  calculateTrackWidth(tracks);\n  generateLaneAssignment();\n\n  if (config.showExonsFlag === true && bed !== null) addTrackFeatures();\n  generateNodeXCoords();\n\n  if (reads && config.showReads) {\n    generateReadOnlyNodeAttributes();\n    reverseReversedReads();\n    generateTrackIndexSequences(reads);\n    placeReads();\n    tracks = tracks.concat(reads);\n    // we do not have any reads to display\n  } else {\n    nodes.forEach(node => {\n      node.incomingReads = [];\n      node.outgoingReads = [];\n      node.internalReads = [];\n    });\n  }\n\n  generateSVGShapesFromPath(nodes, tracks);\n  if (DEBUG) {\n    console.log('Tracks:');\n    console.log(tracks);\n    console.log('Nodes:');\n    console.log(nodes);\n    console.log('Lane assignment:');\n    console.log(assignments);\n  }\n  getImageDimensions();\n  alignSVG(nodes, tracks);\n  defineSVGPatterns();\n\n  drawTrackRectangles(trackRectangles);\n  drawTrackCurves();\n  drawReversalsByColor(trackCorners, trackVerticalRectangles);\n  drawTrackRectangles(trackRectanglesStep3);\n  drawTrackRectangles(trackRectangles, 'read');\n  drawTrackCurves('read');\n\n  // draw only those nodes which have coords assigned to them\n  const dNodes = removeUnusedNodes(nodes);\n  drawReversalsByColor(trackCorners, trackVerticalRectangles, 'read');\n  drawNodes(dNodes);\n  if (config.nodeWidthOption === 0) drawLabels(dNodes);\n  if (trackForRuler !== undefined) drawRuler();\n  if (config.nodeWidthOption === 0) drawMismatches(); // TODO: call this before drawLabels and fix d3 data/append/enter stuff\n  if (DEBUG) {\n    console.log(`number of tracks: ${numberOfTracks}`);\n    console.log(`number of nodes: ${numberOfNodes}`);\n  }\n  return tracks;\n}\n\n// generates attributes (node.y, node.contentHeight) for nodes without tracks, only reads\nfunction generateReadOnlyNodeAttributes() {\n  nodesPerOrder = [];\n  for (let i = 0; i <= maxOrder; i += 1) {\n    nodesPerOrder[i] = [];\n  }\n\n  const orderY = new Map();\n  nodes.forEach(node => {\n    if (node.hasOwnProperty('order') && node.hasOwnProperty('y')) {\n      setMapToMax(orderY, node.order, node.y + node.contentHeight);\n    }\n  });\n\n  // for order values where there is no node with haplotypes, orderY is calculated via tracks\n  tracks.forEach(track => {\n    if (track.type === 'haplo') {\n      track.path.forEach(step => {\n        setMapToMax(orderY, step.order, step.y + track.width);\n      });\n    }\n  });\n\n  nodes.forEach((node, i) => {\n    if (node.hasOwnProperty('order') && !node.hasOwnProperty('y')) {\n      node.y = orderY.get(node.order) + 25;\n      node.contentHeight = 0;\n      nodesPerOrder[node.order].push(i);\n    }\n  });\n}\n\nfunction setMapToMax(map, key, value) {\n  if (map.has(key)) {\n    map.set(key, Math.max(map.get(key), value));\n  } else {\n    map.set(key, value);\n  }\n}\n\n// add info about reads to nodes (incoming, outgoing and internal reads)\nfunction assignReadsToNodes() {\n  nodes.forEach(node => {\n    node.incomingReads = [];\n    node.outgoingReads = [];\n    node.internalReads = [];\n  });\n  reads.forEach((read, idx) => {\n    read.width = 7;\n    if (read.path.length === 1) {\n      nodes[read.path[0].node].internalReads.push(idx);\n    } else {\n      read.path.forEach((element, pathIdx) => {\n        if (pathIdx === 0) {\n          nodes[read.path[0].node].outgoingReads.push([idx, pathIdx]);\n        } else if (read.path[pathIdx].node !== null) {\n          nodes[read.path[pathIdx].node].incomingReads.push([idx, pathIdx]);\n        }\n      });\n    }\n  });\n}\n\nfunction removeNonPathNodesFromReads() {\n  reads.forEach(read => {\n    for (let i = read.sequence.length - 1; i >= 0; i -= 1) {\n      let nodeName = forward(read.sequence[i]);\n      if (!nodeMap.has(nodeName) || nodes[nodeMap.get(nodeName)].degree === 0) {\n        read.sequence.splice(i, 1);\n      }\n    }\n  });\n}\n\n// calculate paths (incl. correct y coordinate) for all reads\nfunction placeReads() {\n  generateBasicPathsForReads();\n  assignReadsToNodes();\n\n  // sort nodes by order, then by y-coordinate\n  const sortedNodes = nodes.slice();\n  sortedNodes.sort(compareNodesByOrder);\n\n  // iterate over all nodes\n  sortedNodes.forEach(node => {\n    // sort incoming reads\n    node.incomingReads.sort(compareReadIncomingSegmentsByComingFrom);\n\n    // place incoming reads\n    let currentY = node.y + node.contentHeight;\n    const occupiedUntil = new Map();\n    node.incomingReads.forEach(readElement => {\n      reads[readElement[0]].path[readElement[1]].y = currentY;\n      setOccupiedUntil(\n        occupiedUntil,\n        reads[readElement[0]],\n        readElement[1],\n        currentY,\n        node\n      );\n      currentY += 7;\n    });\n    let maxY = currentY;\n\n    // sort outgoing reads\n    node.outgoingReads.sort(compareReadOutgoingSegmentsByGoingTo);\n\n    // place outgoing reads\n    const occupiedFrom = new Map();\n    currentY = node.y + node.contentHeight;\n    node.outgoingReads.forEach(readElement => {\n      // place in next lane\n      reads[readElement[0]].path[readElement[1]].y = currentY;\n      occupiedFrom.set(currentY, reads[readElement[0]].firstNodeOffset);\n      // if no conflicts\n      if (\n        !occupiedUntil.has(currentY) ||\n        occupiedUntil.get(currentY) + 1 < reads[readElement[0]].firstNodeOffset\n      ) {\n        currentY += 7;\n        maxY = Math.max(maxY, currentY);\n      } else {\n        // otherwise push down incoming reads to make place for outgoing Read\n        occupiedUntil.set(currentY, 0);\n        node.incomingReads.forEach(incReadElementIndices => {\n          const incRead = reads[incReadElementIndices[0]];\n          const incReadPathElement = incRead.path[incReadElementIndices[1]];\n          if (incReadPathElement.y >= currentY) {\n            incReadPathElement.y += 7;\n            setOccupiedUntil(\n              occupiedUntil,\n              incRead,\n              incReadElementIndices[1],\n              incReadPathElement.y,\n              node\n            );\n          }\n        });\n        currentY += 7;\n        maxY += 7;\n      }\n    });\n\n    // sort internal reads\n    node.internalReads.sort(compareInternalReads);\n\n    // place internal reads\n    node.internalReads.forEach(readIdx => {\n      const currentRead = reads[readIdx];\n      currentY = node.y + node.contentHeight;\n      while (\n        currentRead.firstNodeOffset < occupiedUntil.get(currentY) + 2 ||\n        currentRead.finalNodeCoverLength > occupiedFrom.get(currentY) - 3\n      ) {\n        currentY += 7;\n      }\n      currentRead.path[0].y = currentY;\n      occupiedUntil.set(currentY, currentRead.finalNodeCoverLength);\n      maxY = Math.max(maxY, currentY);\n    });\n\n    // adjust node height and move other nodes vertically down\n    const heightIncrease = maxY - node.y - node.contentHeight;\n    node.contentHeight += heightIncrease;\n    adjustVertically3(node, heightIncrease);\n  });\n\n  // place read segments which are without node\n  const bottomY = calculateBottomY();\n  const elementsWithoutNode = [];\n  reads.forEach((read, idx) => {\n    read.path.forEach((element, pathIdx) => {\n      if (!element.hasOwnProperty('y')) {\n        elementsWithoutNode.push({\n          readIndex: idx,\n          pathIndex: pathIdx,\n          previousY: reads[idx].path[pathIdx - 1].y\n        });\n      }\n    });\n  });\n  elementsWithoutNode.sort(compareNoNodeReadsByPreviousY);\n  elementsWithoutNode.forEach(element => {\n    const segment = reads[element.readIndex].path[element.pathIndex];\n    segment.y = bottomY[segment.order];\n    bottomY[segment.order] += reads[element.readIndex].width;\n  });\n\n  if (DEBUG) {\n    console.log('Reads:');\n    console.log(reads);\n  }\n}\n\n// keeps track of where reads end within nodes\nfunction setOccupiedUntil(map, read, pathIndex, y, node) {\n  if (pathIndex === read.path.length - 1) {\n    // last node of current read\n    map.set(y, read.finalNodeCoverLength);\n  } else {\n    // read covers the whole node\n    map.set(y, node.sequenceLength);\n  }\n}\n\n// compare read segments which are outside of nodes\n// by the y-coord of where they are coming from\nfunction compareNoNodeReadsByPreviousY(a, b) {\n  const segmentA = reads[a.readIndex].path[a.pathIndex];\n  const segmentB = reads[b.readIndex].path[b.pathIndex];\n  if (segmentA.order === segmentB.order) {\n    return a.previousY - b.previousY;\n  }\n  return segmentA.order - segmentB.order;\n}\n\n// compare read segments by where they are going to\nfunction compareReadOutgoingSegmentsByGoingTo(a, b) {\n  let pathIndexA = a[1];\n  let pathIndexB = b[1];\n  // let readA = reads[a[0]]\n  // let nodeIndexA = readA.path[pathIndexA].node;\n  let nodeA = nodes[reads[a[0]].path[pathIndexA].node];\n  let nodeB = nodes[reads[b[0]].path[pathIndexB].node];\n  while (nodeA !== null && nodeB !== null && nodeA === nodeB) {\n    if (pathIndexA < reads[a[0]].path.length - 1) {\n      pathIndexA += 1;\n      while (reads[a[0]].path[pathIndexA].node === null) pathIndexA += 1; // skip null nodes in path\n      nodeA = nodes[reads[a[0]].path[pathIndexA].node];\n    } else {\n      nodeA = null;\n    }\n    if (pathIndexB < reads[b[0]].path.length - 1) {\n      pathIndexB += 1;\n      while (reads[b[0]].path[pathIndexB].node === null) pathIndexB += 1; // skip null nodes in path\n      nodeB = nodes[reads[b[0]].path[pathIndexB].node];\n    } else {\n      nodeB = null;\n    }\n  }\n  if (nodeA !== null) {\n    if (nodeB !== null) return compareNodesByOrder(nodeA, nodeB);\n    return 1; // nodeB is null, nodeA not null\n  }\n  if (nodeB !== null) return -1; // nodeB not null, nodeA null\n  // both nodes are null -> both end in the same node\n  const beginDiff = reads[a[0]].firstNodeOffset - reads[b[0]].firstNodeOffset;\n  if (beginDiff !== 0) return beginDiff;\n  // break tie: both reads cover the same nodes and begin at the same position -> compare by endPosition\n  return reads[a[0]].finalNodeCoverLength - reads[b[0]].finalNodeCoverLength;\n}\n\n// compare read segments by (y-coord of) where they are coming from\nfunction compareReadIncomingSegmentsByComingFrom(a, b) {\n  // these boundary conditions avoid errors for incoming reads\n  // from inverted nodes (u-turns)\n  if (a[1] === 0) return -1;\n  if (b[1] === 0) return 1;\n\n  const pathA = reads[a[0]].path[a[1] - 1];\n  const pathB = reads[b[0]].path[b[1] - 1];\n  if (pathA.hasOwnProperty('y')) {\n    if (pathB.hasOwnProperty('y')) {\n      return pathA.y - pathB.y; // a and b have y-property\n    }\n    return -1; // only a has y-property\n  }\n  if (pathB.hasOwnProperty('y')) {\n    return 1; // only b has y-property\n  }\n  return compareReadIncomingSegmentsByComingFrom(\n    [a[0], a[1] - 1],\n    [b[0], b[1] - 1]\n  ); // neither has y-property\n}\n\n// compare 2 reads which are completely within a single node\nfunction compareInternalReads(idxA, idxB) {\n  const a = reads[idxA];\n  const b = reads[idxB];\n  // compare by first base within first node\n  if (a.firstNodeOffset < b.firstNodeOffset) return -1;\n  else if (a.firstNodeOffset > b.firstNodeOffset) return 1;\n\n  // compare by last base within last node\n  if (a.finalNodeCoverLength < b.finalNodeCoverLength) return -1;\n  else if (a.finalNodeCoverLength > b.finalNodeCoverLength) return 1;\n\n  return 0;\n}\n\n// determine biggest y-coordinate for each order-value\nfunction calculateBottomY() {\n  const bottomY = [];\n  for (let i = 0; i <= maxOrder; i += 1) {\n    bottomY.push(0);\n  }\n\n  nodes.forEach(node => {\n    bottomY[node.order] = Math.max(\n      bottomY[node.order],\n      node.y + node.contentHeight + 20\n    );\n  });\n\n  tracks.forEach(track => {\n    track.path.forEach(element => {\n      bottomY[element.order] = Math.max(\n        bottomY[element.order],\n        element.y + track.width\n      );\n    });\n  });\n  return bottomY;\n}\n\n// generate path-info for each read\n// containing order, node and orientation, but no concrete coordinates\nfunction generateBasicPathsForReads() {\n  let currentNodeIndex;\n  let currentNodeIsForward;\n  let currentNode;\n  let previousNode;\n  let previousNodeIsForward;\n  const isPositive = n => ((n = +n) || 1 / n) >= 0;\n\n  reads.forEach(read => {\n    // add info for start of track\n    currentNodeIndex = Math.abs(read.indexSequence[0]);\n    currentNodeIsForward = isPositive(read.indexSequence[0]);\n    currentNode = nodes[currentNodeIndex];\n\n    read.path = [];\n    read.path.push({\n      order: currentNode.order,\n      isForward: currentNodeIsForward,\n      node: currentNodeIndex\n    });\n\n    for (let i = 1; i < read.sequence.length; i += 1) {\n      previousNode = currentNode;\n      previousNodeIsForward = currentNodeIsForward;\n\n      currentNodeIndex = Math.abs(read.indexSequence[i]);\n      currentNodeIsForward = isPositive(read.indexSequence[i]);\n      currentNode = nodes[currentNodeIndex];\n\n      if (currentNode.order > previousNode.order) {\n        if (!previousNodeIsForward) {\n          // backward to forward at previous node\n          read.path.push({\n            order: previousNode.order,\n            isForward: true,\n            node: null\n          });\n        }\n        for (let j = previousNode.order + 1; j < currentNode.order; j += 1) {\n          // forward without nodes\n          read.path.push({ order: j, isForward: true, node: null });\n        }\n        if (!currentNodeIsForward) {\n          // forward to backward at current node\n          read.path.push({\n            order: currentNode.order,\n            isForward: true,\n            node: null\n          });\n          read.path.push({\n            order: currentNode.order,\n            isForward: false,\n            node: currentNodeIndex\n          });\n        } else {\n          // current Node forward\n          read.path.push({\n            order: currentNode.order,\n            isForward: true,\n            node: currentNodeIndex\n          });\n        }\n      } else if (currentNode.order < previousNode.order) {\n        if (previousNodeIsForward) {\n          // turnaround from fw to bw at previous node\n          read.path.push({\n            order: previousNode.order,\n            isForward: false,\n            node: null\n          });\n        }\n        for (let j = previousNode.order - 1; j > currentNode.order; j -= 1) {\n          // bachward without nodes\n          read.path.push({ order: j, isForward: false, node: null });\n        }\n        if (currentNodeIsForward) {\n          // backward to forward at current node\n          read.path.push({\n            order: currentNode.order,\n            isForward: false,\n            node: null\n          });\n          read.path.push({\n            order: currentNode.order,\n            isForward: true,\n            node: currentNodeIndex\n          });\n        } else {\n          // backward at current node\n          read.path.push({\n            order: currentNode.order,\n            isForward: false,\n            node: currentNodeIndex\n          });\n        }\n      } else {\n        if (currentNodeIsForward !== previousNodeIsForward) {\n          read.path.push({\n            order: currentNode.order,\n            isForward: currentNodeIsForward,\n            node: currentNodeIndex\n          });\n        } else {\n          read.path.push({\n            order: currentNode.order,\n            isForward: !currentNodeIsForward,\n            node: null\n          });\n          read.path.push({\n            order: currentNode.order,\n            isForward: currentNodeIsForward,\n            node: currentNodeIndex\n          });\n        }\n      }\n    }\n  });\n}\n\n// reverse reads which are reversed\nfunction reverseReversedReads() {\n  reads.forEach(read => {\n    let pos = 0;\n    while (pos < read.sequence.length && read.sequence[pos].charAt(0) === '-') {\n      pos += 1;\n    }\n    if (pos === read.sequence.length) {\n      // completely reversed read\n      read.is_reverse = true;\n      read.sequence = read.sequence.reverse(); // invert sequence\n      for (let i = 0; i < read.sequence.length; i += 1) {\n        read.sequence[i] = forward(read.sequence[i]); // visit nodes forward\n        // TODO: Do we really want to visit all the nodes forward here? Are we\n        // sure we aren't in mixed orientation?\n      }\n\n      read.sequenceNew = read.sequenceNew.reverse(); // invert sequence\n      for (let i = 0; i < read.sequenceNew.length; i += 1) {\n        read.sequenceNew[i].nodeName = forward(read.sequenceNew[i].nodeName); // visit nodes forward\n        const nodeWidth =\n          nodes[nodeMap.get(read.sequenceNew[i].nodeName)].width;\n        read.sequenceNew[i].mismatches.forEach(mm => {\n          if (mm.type === 'insertion') {\n            mm.pos = nodeWidth - mm.pos;\n            mm.seq = getReverseComplement(mm.seq);\n          } else if (mm.type === 'deletion') {\n            mm.pos = nodeWidth - mm.pos - mm.length;\n          } else if (mm.type === 'substitution') {\n            mm.pos = nodeWidth - mm.pos - mm.seq.length;\n            mm.seq = getReverseComplement(mm.seq);\n          }\n          if (mm.hasOwnProperty('seq')) {\n            mm.seq = mm.seq\n              .split('')\n              .reverse()\n              .join('');\n          }\n        });\n      }\n\n      // adjust firstNodeOffset and finalNodeCoverLength\n      const temp = read.firstNodeOffset;\n      let seqLength = nodes[nodeMap.get(read.sequence[0])].sequenceLength;\n      read.firstNodeOffset = seqLength - read.finalNodeCoverLength;\n      seqLength =\n        nodes[nodeMap.get(read.sequence[read.sequence.length - 1])]\n          .sequenceLength;\n      read.finalNodeCoverLength = seqLength - temp;\n    }\n  });\n}\n\nfunction getReverseComplement(s) {\n  let result = '';\n  for (let i = s.length - 1; i >= 0; i -= 1) {\n    switch (s.charAt(i)) {\n      case 'A':\n        result += 'T';\n        break;\n      case 'T':\n        result += 'A';\n        break;\n      case 'C':\n        result += 'G';\n        break;\n      case 'G':\n        result += 'C';\n        break;\n      default:\n        result += 'N';\n    }\n  }\n  return result;\n}\n\n// for each track: generate sequence of node indices from seq. of node names\nfunction generateTrackIndexSequences(tracksOrReads) {\n  tracksOrReads.forEach(track => {\n    track.indexSequence = [];\n    track.sequence.forEach(nodeName => {\n      if (isReverse(nodeName)) {\n        track.indexSequence.push(-nodeMap.get(forward(nodeName)));\n      } else {\n        track.indexSequence.push(nodeMap.get(forward(nodeName)));\n      }\n    });\n  });\n}\n\n// remove nodes with no tracks moving through them to avoid d3.js errors\nfunction removeUnusedNodes(allNodes) {\n  const dNodes = allNodes.slice(0);\n  let i;\n  for (i = dNodes.length - 1; i >= 0; i -= 1) {\n    if (!dNodes[i].hasOwnProperty('x')) {\n      dNodes.splice(i, 1);\n    }\n  }\n  return dNodes;\n}\n\n// get the minimum and maximum coordinates used in the image to calculate image dimensions\nfunction getImageDimensions() {\n  maxXCoordinate = -99;\n  minYCoordinate = 99;\n  maxYCoordinate = -99;\n\n  nodes.forEach(node => {\n    if (node.hasOwnProperty('x')) {\n      maxXCoordinate = Math.max(maxXCoordinate, node.x + 20 + node.pixelWidth);\n    }\n    if (node.hasOwnProperty('y')) {\n      minYCoordinate = Math.min(minYCoordinate, node.y - 10);\n      maxYCoordinate = Math.max(\n        maxYCoordinate,\n        node.y + node.contentHeight + 10\n      );\n    }\n  });\n\n  tracks.forEach(track => {\n    track.path.forEach(segment => {\n      maxYCoordinate = Math.max(maxYCoordinate, segment.y + track.width);\n      minYCoordinate = Math.min(minYCoordinate, segment.y);\n    });\n  });\n}\n\n// align visualization to the top and left within svg and resize svg to correct size\n// enable zooming and panning\nfunction alignSVG() {\n  // Find the SVG element.\n  // Trim off the leading \"#\" from the SVG ID.\n  let svgElement = document.getElementById(svgID.substring(1));\n  // And find its parent holding element.\n  let parentElement = svgElement.parentNode;\n\n  svg.attr('height', maxYCoordinate - minYCoordinate + 50);\n  svg.attr(\n    'width',\n    parentElement.offsetWidth\n  );\n\n  function zoomed() {\n    const transform = d3.event.transform;\n    // vertical adjustment so that top of graph is at top of svg\n    // otherwise would violate translateExtent, which leads to graph \"jumping\" on next pan\n    transform.y = (25 - minYCoordinate) * transform.k;\n    svg.attr('transform', transform);\n    const svg2 = d3.select(svgID);\n    // adjust height, so that vertical scroll bar is shown when necessary\n    svg2.attr(\n      'height',\n      (maxYCoordinate - minYCoordinate + 50) * d3.event.transform.k\n    );\n    // adjust width to compensate for verical scroll bar appearing\n    svg2.attr('width', document.getElementById('tubeMapSVG').clientWidth);\n  }\n\n  const minZoom = Math.min(\n    1,\n    parentElement.offsetWidth / (maxXCoordinate + 10)\n  );\n  zoom = d3\n    .zoom()\n    // We need to set an extent here because auto-determination of the region\n    // to zoom breaks on the React testing jsdom\n    .extent([[0, 0], [svg.attr('width'), svg.attr('height')]]) \n    .scaleExtent([minZoom, 8])\n    .translateExtent([\n      [-1, minYCoordinate - 25],\n      [maxXCoordinate + 2, maxYCoordinate + 25]\n    ])\n    .on('zoom', zoomed);\n\n  svg = svg\n    .call(zoom)\n    .on('dblclick.zoom', null)\n    .append('g');\n\n  // translate to correct position on initial draw\n  const containerWidth = parentElement.offsetWidth;\n  const xOffset =\n    maxXCoordinate + 10 < containerWidth\n      ? (containerWidth - maxXCoordinate - 10) / 2\n      : 0;\n  d3.select(document).select(svgID).call(\n    zoom.transform,\n    d3.zoomIdentity.translate(xOffset, 25 - minYCoordinate)\n  );\n}\n\nexport function zoomBy(zoomFactor) {\n  // Find the SVG element.\n  // Trim off the leading \"#\" from the SVG ID.\n  let svgElement = document.getElementById(svgID.substring(1));\n  // And find its parent holding element.\n  let parentElement = svgElement.parentNode;\n  \n  const minZoom = Math.min(\n    1,\n    parentElement.offsetWidth / (maxXCoordinate + 10)\n  );\n  const maxZoom = 8;\n  const width = parentElement.clientWidth;\n\n  const transform = d3.zoomTransform(d3.select(svgID).node());\n  const translateK = Math.min(\n    maxZoom,\n    Math.max(transform.k * zoomFactor, minZoom)\n  );\n  let translateX =\n    width / 2.0 - ((width / 2.0 - transform.x) * translateK) / transform.k;\n  translateX = Math.min(translateX, 1 * translateK);\n  translateX = Math.max(translateX, width - (maxXCoordinate + 2) * translateK);\n  const translateY = (25 - minYCoordinate) * translateK;\n  d3.select(svgID)\n    .transition()\n    .duration(750)\n    .call(\n      zoom.transform,\n      d3.zoomIdentity.translate(translateX, translateY).scale(translateK)\n    );\n}\n\n// map node names to node indices\nfunction generateNodeMap() {\n  nodeMap = new Map();\n  nodes.forEach((node, index) => {\n    nodeMap.set(node.name, index);\n  });\n  return nodeMap;\n}\n\n// adds a successor-array to each node containing the indices of the nodes coming directly after the current node\nfunction generateNodeSuccessors() {\n  let current;\n  let follower;\n\n  nodes.forEach(node => {\n    node.successors = [];\n    node.predecessors = [];\n  });\n\n  tracks.forEach(track => {\n    for (let i = 0; i < track.indexSequence.length - 1; i += 1) {\n      current = Math.abs(track.indexSequence[i]);\n      follower = Math.abs(track.indexSequence[i + 1]);\n      if (nodes[current].successors.indexOf(follower) === -1) {\n        nodes[current].successors.push(follower);\n      }\n      if (nodes[follower].predecessors.indexOf(current) === -1) {\n        nodes[follower].predecessors.push(current);\n      }\n    }\n  });\n\n  if (reads && config.showReads) {\n    reads.forEach(track => {\n      for (let i = 0; i < track.indexSequence.length - 1; i += 1) {\n        current = Math.abs(track.indexSequence[i]);\n        follower = Math.abs(track.indexSequence[i + 1]);\n        if (nodes[current].successors.indexOf(follower) === -1) {\n          nodes[current].successors.push(follower);\n        }\n        if (nodes[follower].predecessors.indexOf(current) === -1) {\n          nodes[follower].predecessors.push(current);\n        }\n      }\n    });\n  }\n}\n\nfunction generateNodeOrderOfSingleTrack(sequence) {\n  let forwardOrder = 0;\n  let backwardOrder = 0;\n  let currentNode;\n  let minOrder = 0;\n\n  sequence.forEach(nodeIndex => {\n    if (nodeIndex < 0) {\n      currentNode = nodes[Math.abs(nodeIndex)];\n      if (!currentNode.hasOwnProperty('order')) {\n        currentNode.order = backwardOrder;\n      }\n      if (currentNode.order < minOrder) minOrder = currentNode.order;\n      forwardOrder = currentNode.order;\n      backwardOrder = currentNode.order - 1;\n    } else {\n      currentNode = nodes[nodeIndex];\n      if (!currentNode.hasOwnProperty('order')) {\n        currentNode.order = forwardOrder;\n      }\n      forwardOrder = currentNode.order + 1;\n      backwardOrder = currentNode.order;\n    }\n  });\n  if (minOrder < 0) {\n    increaseOrderForAllNodes(-minOrder);\n  }\n}\n\n// calculate the order-value of nodes contained in sequence which are to the left of the first node which already has an order-value\nfunction generateNodeOrderTrackBeginning(sequence) {\n  let anchorIndex = 0;\n  let currentOrder;\n  let currentNode;\n  let minOrder = 0;\n  let increment;\n\n  while (\n    anchorIndex < sequence.length &&\n    !nodes[Math.abs(sequence[anchorIndex])].hasOwnProperty('order')\n  ) {\n    anchorIndex += 1; // anchor = first node in common with existing graph\n  }\n  if (anchorIndex >= sequence.length) {\n    return null;\n  }\n\n  if (sequence[anchorIndex] >= 0) {\n    // regular node\n    currentOrder = nodes[sequence[anchorIndex]].order - 1;\n    increment = -1;\n  } else {\n    // reverse node\n    currentOrder = nodes[-sequence[anchorIndex]].order + 1;\n    increment = 1;\n  }\n\n  for (let j = anchorIndex - 1; j >= 0; j -= 1) {\n    // assign order to nodes which are left of anchor node\n    currentNode = nodes[Math.abs(sequence[j])];\n    if (!currentNode.hasOwnProperty('order')) {\n      currentNode.order = currentOrder;\n      minOrder = Math.min(minOrder, currentOrder);\n      currentOrder += increment;\n    }\n  }\n\n  if (minOrder < 0) {\n    increaseOrderForAllNodes(-minOrder);\n  }\n  return anchorIndex;\n}\n\n// generate global sequence of nodes from left to right, starting with first track and adding other tracks sequentially\nfunction generateNodeOrder() {\n  let modifiedSequence;\n  let currentOrder;\n  let currentNode;\n  let rightIndex;\n  let leftIndex;\n  let minOrder = 0;\n  let tracksAndReads;\n  if (reads && config.showReads) tracksAndReads = tracks.concat(reads);\n  else tracksAndReads = tracks;\n\n  nodes.forEach(node => {\n    delete node.order;\n  });\n\n  generateNodeOrderOfSingleTrack(tracks[0].indexSequence); // calculate order values for all nodes of the first track\n\n  for (let i = 1; i < tracksAndReads.length; i += 1) {\n    if (DEBUG) console.log(`generating order for track ${i + 1}`);\n    rightIndex = generateNodeOrderTrackBeginning(\n      tracksAndReads[i].indexSequence\n    ); // calculate order values for all nodes until the first anchor\n    if (rightIndex === null) {\n      if (tracksAndReads[i].type === 'haplo') {\n        generateNodeOrderOfSingleTrack(tracksAndReads[i].indexSequence);\n      } else {\n        tracksAndReads.splice(i, 1);\n        reads.splice(i - tracks.length, 1);\n        i -= 1;\n      }\n      continue;\n    }\n    // Create a sequence with orientation removed and everything\n    // positive/forward\n    modifiedSequence = uninvert(tracksAndReads[i].indexSequence);\n\n    while (rightIndex < modifiedSequence.length) {\n      // move right until the end of the sequence\n      // find next anchor node\n      leftIndex = rightIndex;\n      rightIndex += 1;\n      while (\n        rightIndex < modifiedSequence.length &&\n        !nodes[modifiedSequence[rightIndex]].hasOwnProperty('order')\n      ) {\n        rightIndex += 1;\n      }\n\n      if (rightIndex < modifiedSequence.length) {\n        // middle segment between two anchors\n        currentOrder = nodes[modifiedSequence[leftIndex]].order + 1; // start with order value of leftAnchor + 1\n        for (let j = leftIndex + 1; j < rightIndex; j += 1) {\n          nodes[modifiedSequence[j]].order = currentOrder; // assign order values\n          currentOrder += 1;\n        }\n\n        if (\n          nodes[modifiedSequence[rightIndex]].order >\n          nodes[modifiedSequence[leftIndex]].order\n        ) {\n          // if order-value of left anchor < order-value of right anchor\n          if (nodes[modifiedSequence[rightIndex]].order < currentOrder) {\n            // and the right anchor now has a lower order-value than our newly added nodes\n            increaseOrderForSuccessors(\n              modifiedSequence[rightIndex],\n              modifiedSequence[rightIndex - 1],\n              currentOrder\n            );\n          }\n        } else {\n          // potential node reversal: check for ordering conflict, if no conflict found move node at rightIndex further to the right in order to not create a track reversal\n          if (\n            tracksAndReads[i].indexSequence[rightIndex] >= 0 &&\n            !isSuccessor(\n              modifiedSequence[rightIndex],\n              modifiedSequence[leftIndex]\n            )\n          ) {\n            // no real reversal\n            increaseOrderForSuccessors(\n              modifiedSequence[rightIndex],\n              modifiedSequence[rightIndex - 1],\n              currentOrder\n            );\n          } else {\n            // real reversal\n            if (\n              tracksAndReads[i].sequence[leftIndex] < 0 ||\n              (nodes[modifiedSequence[leftIndex + 1]].degree < 2 &&\n                nodes[modifiedSequence[rightIndex]].order <\n                  nodes[modifiedSequence[leftIndex]].order)\n            ) {\n              currentOrder = nodes[modifiedSequence[leftIndex]].order - 1; // start with order value of leftAnchor - 1\n              for (let j = leftIndex + 1; j < rightIndex; j += 1) {\n                nodes[modifiedSequence[j]].order = currentOrder; // assign order values\n                currentOrder -= 1;\n              }\n            }\n          }\n        }\n      } else {\n        // right segment to the right of last anchor\n        if (tracksAndReads[i].sequence[leftIndex] >= 0) {\n          // elongate towards the right\n          currentOrder = nodes[modifiedSequence[leftIndex]].order + 1;\n          for (let j = leftIndex + 1; j < modifiedSequence.length; j += 1) {\n            currentNode = nodes[modifiedSequence[j]];\n            if (!currentNode.hasOwnProperty('order')) {\n              currentNode.order = currentOrder;\n              currentOrder += 1;\n            }\n          }\n        } else {\n          // elongate towards the left\n          currentOrder = nodes[modifiedSequence[leftIndex]].order - 1;\n          for (let j = leftIndex + 1; j < modifiedSequence.length; j += 1) {\n            currentNode = nodes[modifiedSequence[j]];\n            if (!currentNode.hasOwnProperty('order')) {\n              currentNode.order = currentOrder;\n              minOrder = Math.min(minOrder, currentOrder);\n              currentOrder -= 1;\n            }\n          }\n        }\n      }\n    }\n  }\n\n  // adjust all nodes if necessary, so that no order<0\n  if (minOrder < 0) increaseOrderForAllNodes(-minOrder);\n}\n\nfunction isSuccessor(first, second) {\n  const visited = new Array(numberOfNodes).fill(false);\n  const stack = [];\n  stack.push(first);\n  visited[first] = true;\n  while (stack.length > 0) {\n    const current = stack.pop();\n    if (current === second) return true;\n    for (let i = 0; i < nodes[current].successors.length; i += 1) {\n      const childIndex = nodes[current].successors[i];\n      if (!visited[childIndex]) {\n        visited[childIndex] = true;\n        stack.push(childIndex);\n      }\n    }\n  }\n  return false;\n}\n\n// get order number of the rightmost node\nfunction getMaxOrder() {\n  let max = -1;\n  nodes.forEach(node => {\n    if (node.hasOwnProperty('order') && node.order > max) max = node.order;\n  });\n  return max;\n}\n\n// generates sequence keeping the order but switching all reversed (negative) nodes to forward nodes\nfunction uninvert(sequence) {\n  const result = [];\n  for (let i = 0; i < sequence.length; i += 1) {\n    if (sequence[i] >= 0) {\n      result.push(sequence[i]);\n    } else {\n      result.push(-sequence[i]);\n    }\n  }\n  return result;\n}\n\n// increases the order-value of all nodes by amount\nfunction increaseOrderForAllNodes(amount) {\n  nodes.forEach(node => {\n    if (node.hasOwnProperty('order')) node.order += amount;\n  });\n}\n\n// increases the order-value for currentNode and (if necessary) successor nodes recursively\nfunction increaseOrderForSuccessors(startingNode, tabuNode, newOrder) {\n  const increasedOrders = new Map();\n  const queue = [];\n  queue.push([startingNode, newOrder]);\n\n  while (queue.length > 0) {\n    const current = queue.shift();\n    const currentNode = current[0];\n    const currentOrder = current[1];\n\n    if (\n      nodes[currentNode].hasOwnProperty('order') &&\n      nodes[currentNode].order < currentOrder\n    ) {\n      if (\n        !increasedOrders.has(currentNode) ||\n        increasedOrders.get(currentNode) < currentOrder\n      ) {\n        increasedOrders.set(currentNode, currentOrder);\n        nodes[currentNode].successors.forEach(successor => {\n          if (\n            nodes[successor].order > nodes[currentNode].order &&\n            successor !== tabuNode\n          ) {\n            // only increase order of successors if they lie to the right of the currentNode (not for repeats/translocations)\n            queue.push([successor, currentOrder + 1]);\n          }\n        });\n        if (currentNode !== startingNode) {\n          nodes[currentNode].predecessors.forEach(predecessor => {\n            if (\n              nodes[predecessor].order > currentNode.order &&\n              predecessor !== tabuNode\n            ) {\n              // only increase order of predecessors if they lie to the right of the currentNode (not for repeats/translocations)\n              queue.push([predecessor, currentOrder + 1]);\n            }\n          });\n        }\n      }\n    }\n  }\n\n  increasedOrders.forEach((value, key) => {\n    nodes[key].order = value;\n  });\n}\n\n// calculates the node degree: the number of tracks passing through the node / the node height\nfunction generateNodeDegree() {\n  nodes.forEach(node => {\n    node.tracks = [];\n  });\n\n  tracks.forEach(track => {\n    track.indexSequence.forEach(nodeIndex => {\n      nodes[Math.abs(nodeIndex)].tracks.push(track.id);\n    });\n  });\n\n  nodes.forEach(node => {\n    if (node.hasOwnProperty('tracks')) node.degree = node.tracks.length;\n  });\n}\n\n// if more tracks pass through a specific node in reverse direction than in\n// regular direction, switch its orientation\n// (does not apply to the first track's nodes, these are always oriented as\n// dictated by the first track)\nfunction switchNodeOrientation() {\n  const toSwitch = new Map();\n  let nodeName;\n  let prevNode;\n  let nextNode;\n  let currentNode;\n\n  for (let i = 1; i < tracks.length; i += 1) {\n    for (let j = 0; j < tracks[i].sequence.length; j += 1) {\n      nodeName = tracks[i].sequence[j];\n      nodeName = forward(nodeName);\n      currentNode = nodes[nodeMap.get(nodeName)];\n      if (tracks[0].sequence.indexOf(nodeName) === -1) {\n        // do not change orientation for nodes which are part of the pivot track\n        if (j > 0) {\n          prevNode = nodes[nodeMap.get(forward(tracks[i].sequence[j - 1]))]\n        }\n        if (j < tracks[i].sequence.length - 1) {\n            nextNode = nodes[nodeMap.get(forward(tracks[i].sequence[j + 1]))];\n        }\n        if (\n          (j === 0 || prevNode.order < currentNode.order) &&\n          (j === tracks[i].sequence.length - 1 ||\n            currentNode.order < nextNode.order)\n        ) {\n          if (!toSwitch.has(nodeName)) toSwitch.set(nodeName, 0);\n          if (isReverse(tracks[i].sequence[j])) {\n            toSwitch.set(nodeName, toSwitch.get(nodeName) + 1);\n          } else {\n            toSwitch.set(nodeName, toSwitch.get(nodeName) - 1);\n          }\n        }\n        if (\n          (j === 0 || prevNode.order > currentNode.order) &&\n          (j === tracks[i].sequence.length - 1 ||\n            currentNode.order > nextNode.order)\n        ) {\n          if (!toSwitch.has(nodeName)) toSwitch.set(nodeName, 0);\n          if (isReverse(tracks[i].sequence[j])) {\n            toSwitch.set(nodeName, toSwitch.get(nodeName) - 1);\n          } else {\n            toSwitch.set(nodeName, toSwitch.get(nodeName) + 1);\n          }\n        }\n      }\n    }\n  }\n\n  tracks.forEach((track, trackIndex) => {\n    track.sequence.forEach((node, nodeIndex) => {\n      nodeName = forward(node);\n      if (toSwitch.has(nodeName) && toSwitch.get(nodeName) > 0) {\n        tracks[trackIndex].sequence[nodeIndex] = flip(node);\n      }\n    });\n  });\n\n  // invert the sequence within the nodes\n  toSwitch.forEach((value, key) => {\n    if (value > 0) {\n      currentNode = nodeMap.get(key);\n      nodes[currentNode].seq = nodes[currentNode].seq\n        .split('')\n        .reverse()\n        .join('');\n    }\n  });\n}\n\n// calculates the concrete values for the nodes' x-coordinates\nfunction generateNodeXCoords() {\n  let currentX = 0;\n  let nextX = 20;\n  let currentOrder = -1;\n  const sortedNodes = nodes.slice();\n  sortedNodes.sort(compareNodesByOrder);\n  const extra = calculateExtraSpace();\n\n  sortedNodes.forEach(node => {\n    if (node.hasOwnProperty('order')) {\n      if (node.order > currentOrder) {\n        currentOrder = node.order;\n        currentX = nextX + 10 * extra[node.order];\n      }\n      node.x = currentX;\n      nextX = Math.max(nextX, currentX + 40 + node.pixelWidth);\n    }\n  });\n}\n\n// calculates additional horizontal space needed between two nodes\n// two neighboring nodes have to be moved further apart if there is a lot going on in between them\n// -> edges turning to vertical orientation should not overlap\nfunction calculateExtraSpace() {\n  const leftSideEdges = [];\n  const rightSideEdges = [];\n  const extra = [];\n\n  for (let i = 0; i <= maxOrder; i += 1) {\n    leftSideEdges.push(0);\n    rightSideEdges.push(0);\n  }\n\n  tracks.forEach(track => {\n    for (let i = 1; i < track.path.length; i += 1) {\n      if (track.path[i].order === track.path[i - 1].order) {\n        // repeat or translocation\n        if (track.path[i].isForward === true) {\n          leftSideEdges[track.path[i].order] += 1;\n        } else {\n          rightSideEdges[track.path[i].order] += 1;\n        }\n      }\n    }\n  });\n\n  extra.push(Math.max(0, leftSideEdges[0] - 1));\n  for (let i = 1; i <= maxOrder; i += 1) {\n    extra.push(\n      Math.max(0, leftSideEdges[i] - 1) + Math.max(0, rightSideEdges[i - 1] - 1)\n    );\n  }\n  return extra;\n}\n\n// create and fill assignment-variable, which contains info about tracks and lanes for each order-value\nfunction generateLaneAssignment() {\n  let segmentNumber;\n  let currentNodeIndex;\n  let currentNodeIsForward;\n  let currentNode;\n  let previousNode;\n  let previousNodeIsForward;\n  const prevSegmentPerOrderPerTrack = [];\n  const isPositive = n => ((n = +n) || 1 / n) >= 0;\n\n  // create empty variables\n  for (let i = 0; i <= maxOrder; i += 1) {\n    assignments[i] = [];\n    prevSegmentPerOrderPerTrack[i] = [];\n    for (let j = 0; j < numberOfTracks; j += 1) {\n      prevSegmentPerOrderPerTrack[i][j] = null;\n    }\n  }\n\n  tracks.forEach((track, trackNo) => {\n    // add info for start of track\n    currentNodeIndex = Math.abs(track.indexSequence[0]);\n    currentNodeIsForward = isPositive(track.indexSequence[0]);\n    currentNode = nodes[currentNodeIndex];\n\n    track.path = [];\n    track.path.push({\n      order: currentNode.order,\n      lane: null,\n      isForward: currentNodeIsForward,\n      node: currentNodeIndex\n    });\n    addToAssignment(\n      currentNode.order,\n      currentNodeIndex,\n      trackNo,\n      0,\n      prevSegmentPerOrderPerTrack\n    );\n\n    segmentNumber = 1;\n    for (let i = 1; i < track.sequence.length; i += 1) {\n      previousNode = currentNode;\n      previousNodeIsForward = currentNodeIsForward;\n\n      currentNodeIndex = Math.abs(track.indexSequence[i]);\n      currentNodeIsForward = isPositive(track.indexSequence[i]);\n      currentNode = nodes[currentNodeIndex];\n\n      if (currentNode.order > previousNode.order) {\n        if (!previousNodeIsForward) {\n          // backward to forward at previous node\n          track.path.push({\n            order: previousNode.order,\n            lane: null,\n            isForward: true,\n            node: null\n          });\n          addToAssignment(\n            previousNode.order,\n            null,\n            trackNo,\n            segmentNumber,\n            prevSegmentPerOrderPerTrack\n          );\n          segmentNumber += 1;\n        }\n        for (let j = previousNode.order + 1; j < currentNode.order; j += 1) {\n          // forward without nodes\n          track.path.push({\n            order: j,\n            lane: null,\n            isForward: true,\n            node: null\n          });\n          addToAssignment(\n            j,\n            null,\n            trackNo,\n            segmentNumber,\n            prevSegmentPerOrderPerTrack\n          );\n          segmentNumber += 1;\n        }\n        if (!currentNodeIsForward) {\n          // forward to backward at current node\n          track.path.push({\n            order: currentNode.order,\n            lane: null,\n            isForward: true,\n            node: null\n          });\n          addToAssignment(\n            currentNode.order,\n            null,\n            trackNo,\n            segmentNumber,\n            prevSegmentPerOrderPerTrack\n          );\n          segmentNumber += 1;\n          track.path.push({\n            order: currentNode.order,\n            lane: null,\n            isForward: false,\n            node: currentNodeIndex\n          });\n          addToAssignment(\n            currentNode.order,\n            currentNodeIndex,\n            trackNo,\n            segmentNumber,\n            prevSegmentPerOrderPerTrack\n          );\n          segmentNumber += 1;\n        } else {\n          // current Node forward\n          track.path.push({\n            order: currentNode.order,\n            lane: null,\n            isForward: true,\n            node: currentNodeIndex\n          });\n          addToAssignment(\n            currentNode.order,\n            currentNodeIndex,\n            trackNo,\n            segmentNumber,\n            prevSegmentPerOrderPerTrack\n          );\n          segmentNumber += 1;\n        }\n      } else if (currentNode.order < previousNode.order) {\n        if (previousNodeIsForward) {\n          // turnaround from fw to bw at previous node\n          track.path.push({\n            order: previousNode.order,\n            lane: null,\n            isForward: false,\n            node: null\n          });\n          addToAssignment(\n            previousNode.order,\n            null,\n            trackNo,\n            segmentNumber,\n            prevSegmentPerOrderPerTrack\n          );\n          segmentNumber += 1;\n        }\n        for (let j = previousNode.order - 1; j > currentNode.order; j -= 1) {\n          // bachward without nodes\n          track.path.push({\n            order: j,\n            lane: null,\n            isForward: false,\n            node: null\n          });\n          addToAssignment(\n            j,\n            null,\n            trackNo,\n            segmentNumber,\n            prevSegmentPerOrderPerTrack\n          );\n          segmentNumber += 1;\n        }\n        if (currentNodeIsForward) {\n          // backward to forward at current node\n          track.path.push({\n            order: currentNode.order,\n            lane: null,\n            isForward: false,\n            node: null\n          });\n          addToAssignment(\n            currentNode.order,\n            null,\n            trackNo,\n            segmentNumber,\n            prevSegmentPerOrderPerTrack\n          );\n          segmentNumber += 1;\n          track.path.push({\n            order: currentNode.order,\n            lane: null,\n            isForward: true,\n            node: currentNodeIndex\n          });\n          addToAssignment(\n            currentNode.order,\n            currentNodeIndex,\n            trackNo,\n            segmentNumber,\n            prevSegmentPerOrderPerTrack\n          );\n          segmentNumber += 1;\n        } else {\n          // backward at current node\n          track.path.push({\n            order: currentNode.order,\n            lane: null,\n            isForward: false,\n            node: currentNodeIndex\n          });\n          addToAssignment(\n            currentNode.order,\n            currentNodeIndex,\n            trackNo,\n            segmentNumber,\n            prevSegmentPerOrderPerTrack\n          );\n          segmentNumber += 1;\n        }\n      } else {\n        if (currentNodeIsForward !== previousNodeIsForward) {\n          track.path.push({\n            order: currentNode.order,\n            lane: null,\n            isForward: currentNodeIsForward,\n            node: currentNodeIndex\n          });\n          addToAssignment(\n            currentNode.order,\n            currentNodeIndex,\n            trackNo,\n            segmentNumber,\n            prevSegmentPerOrderPerTrack\n          );\n          segmentNumber += 1;\n        } else {\n          track.path.push({\n            order: currentNode.order,\n            lane: null,\n            isForward: !currentNodeIsForward,\n            node: null\n          });\n          addToAssignment(\n            currentNode.order,\n            null,\n            trackNo,\n            segmentNumber,\n            prevSegmentPerOrderPerTrack\n          );\n          segmentNumber += 1;\n          track.path.push({\n            order: currentNode.order,\n            lane: null,\n            isForward: currentNodeIsForward,\n            node: currentNodeIndex\n          });\n          addToAssignment(\n            currentNode.order,\n            currentNodeIndex,\n            trackNo,\n            segmentNumber,\n            prevSegmentPerOrderPerTrack\n          );\n          segmentNumber += 1;\n        }\n      }\n    }\n  });\n\n  for (let i = 0; i <= maxOrder; i += 1) {\n    generateSingleLaneAssignment(assignments[i], i); // this is where the lanes get assigned\n  }\n}\n\nfunction addToAssignment(\n  order,\n  nodeIndex,\n  trackNo,\n  segmentID,\n  prevSegmentPerOrderPerTrack\n) {\n  const compareToFromSame = prevSegmentPerOrderPerTrack[order][trackNo];\n\n  if (nodeIndex === null) {\n    assignments[order].push({\n      type: 'single',\n      node: null,\n      tracks: [{ trackID: trackNo, segmentID, compareToFromSame }]\n    });\n    prevSegmentPerOrderPerTrack[order][trackNo] =\n      assignments[order][assignments[order].length - 1].tracks[0];\n  } else {\n    for (let i = 0; i < assignments[order].length; i += 1) {\n      if (assignments[order][i].node === nodeIndex) {\n        // add to existing node in assignment\n        assignments[order][i].type = 'multiple';\n        assignments[order][i].tracks.push({\n          trackID: trackNo,\n          segmentID,\n          compareToFromSame\n        });\n        prevSegmentPerOrderPerTrack[order][trackNo] =\n          assignments[order][i].tracks[assignments[order][i].tracks.length - 1];\n        return;\n      }\n    }\n    // create new node in assignment\n    assignments[order].push({\n      type: 'single',\n      node: nodeIndex,\n      tracks: [{ trackID: trackNo, segmentID, compareToFromSame }]\n    });\n    prevSegmentPerOrderPerTrack[order][trackNo] =\n      assignments[order][assignments[order].length - 1].tracks[0];\n  }\n}\n\n// looks at assignment and sets idealY and idealLane by looking at where the tracks come from\nfunction getIdealLanesAndCoords(assignment, order) {\n  let index;\n\n  assignment.forEach(node => {\n    node.idealLane = 0;\n    node.tracks.forEach(track => {\n      if (track.segmentID === 0) {\n        track.idealLane = track.trackID;\n        track.idealY = null;\n      } else {\n        if (\n          tracks[track.trackID].path[track.segmentID - 1].order ===\n          order - 1\n        ) {\n          track.idealLane =\n            tracks[track.trackID].path[track.segmentID - 1].lane;\n          track.idealY = tracks[track.trackID].path[track.segmentID - 1].y;\n        } else if (\n          track.segmentID < tracks[track.trackID].path.length - 1 &&\n          tracks[track.trackID].path[track.segmentID + 1].order === order - 1\n        ) {\n          track.idealLane =\n            tracks[track.trackID].path[track.segmentID + 1].lane;\n          track.idealY = tracks[track.trackID].path[track.segmentID + 1].y;\n        } else {\n          index = track.segmentID - 1;\n          while (\n            index >= 0 &&\n            tracks[track.trackID].path[index].order !== order - 1\n          ) {\n            index -= 1;\n          }\n          if (index < 0) {\n            track.idealLane = track.trackID;\n            track.idealY = null;\n          } else {\n            track.idealLane = tracks[track.trackID].path[index].lane;\n            track.idealY = tracks[track.trackID].path[index].y;\n          }\n        }\n      }\n      node.idealLane += track.idealLane;\n    });\n    node.idealLane /= node.tracks.length;\n  });\n}\n\n// assigns the optimal lanes for a single horizontal position (=order)\n// first an ideal lane is calculated for each track (which is ~ the lane of its predecessor)\n// then the nodes are sorted by their average ideal lane\n// and the whole construct is then moved up or down if necessary\nfunction generateSingleLaneAssignment(assignment, order) {\n  let currentLane = 0;\n  const potentialAdjustmentValues = new Set();\n  let currentY = 20;\n  let prevNameIsNull = false;\n  let prevTrack = -1;\n\n  getIdealLanesAndCoords(assignment, order);\n  assignment.sort(compareByIdealLane);\n\n  assignment.forEach(node => {\n    if (node.node !== null) {\n      nodes[node.node].topLane = currentLane;\n      if (prevNameIsNull) currentY -= 10;\n      nodes[node.node].y = currentY;\n      nodes[node.node].contentHeight = 0;\n      prevNameIsNull = false;\n    } else {\n      if (prevNameIsNull) currentY -= 25;\n      else if (currentY > 20) currentY -= 10;\n      prevNameIsNull = true;\n    }\n\n    node.tracks.sort(compareByIdealLane);\n    node.tracks.forEach(track => {\n      track.lane = currentLane;\n      if (track.trackID === prevTrack && node.node === null && prevNameIsNull) {\n        currentY += 10;\n      }\n      tracks[track.trackID].path[track.segmentID].lane = currentLane;\n      tracks[track.trackID].path[track.segmentID].y = currentY;\n      if (track.idealY !== null) {\n        potentialAdjustmentValues.add(track.idealY - currentY);\n      }\n      currentLane += 1;\n      currentY += tracks[track.trackID].width;\n      if (node.node !== null) {\n        nodes[node.node].contentHeight += tracks[track.trackID].width;\n      }\n      prevTrack = track.trackID;\n    });\n    currentY += 25;\n  });\n\n  adjustVertically(assignment, potentialAdjustmentValues);\n}\n\n// moves all tracks at a single horizontal location (=order) up/down to minimize lane changes\nfunction adjustVertically(assignment, potentialAdjustmentValues) {\n  let verticalAdjustment = 0;\n  let minAdjustmentCost = Number.MAX_SAFE_INTEGER;\n\n  potentialAdjustmentValues.forEach(moveBy => {\n    if (getVerticalAdjustmentCost(assignment, moveBy) < minAdjustmentCost) {\n      minAdjustmentCost = getVerticalAdjustmentCost(assignment, moveBy);\n      verticalAdjustment = moveBy;\n    }\n  });\n\n  assignment.forEach(node => {\n    if (node.node !== null) {\n      nodes[node.node].y += verticalAdjustment;\n    }\n    node.tracks.forEach(track => {\n      tracks[track.trackID].path[track.segmentID].y += verticalAdjustment;\n    });\n  });\n}\n\nfunction adjustVertically3(node, adjustBy) {\n  if (node.hasOwnProperty('order')) {\n    assignments[node.order].forEach(assignmentNode => {\n      if (assignmentNode.node !== null) {\n        const aNode = nodes[assignmentNode.node];\n        if (aNode !== node && aNode.y > node.y) {\n          aNode.y += adjustBy;\n          assignmentNode.tracks.forEach(track => {\n            tracks[track.trackID].path[track.segmentID].y += adjustBy;\n          });\n        }\n      } else {\n        // track-segment not within a node\n        assignmentNode.tracks.forEach(track => {\n          if (tracks[track.trackID].path[track.segmentID].y >= node.y) {\n            tracks[track.trackID].path[track.segmentID].y += adjustBy;\n          }\n        });\n      }\n    });\n    if (nodesPerOrder[node.order].length > 0) {\n      nodesPerOrder[node.order].forEach(nodeIndex => {\n        if (nodes[nodeIndex] !== node && nodes[nodeIndex].y > node.y) {\n          nodes[nodeIndex].y += adjustBy;\n        }\n      });\n    }\n  }\n}\n\n// calculates cost of vertical adjustment as vertical distance * width of track\nfunction getVerticalAdjustmentCost(assignment, moveBy) {\n  let result = 0;\n  assignment.forEach(node => {\n    node.tracks.forEach(track => {\n      if (track.idealY !== null && tracks[track.trackID].type !== 'read') {\n        result +=\n          Math.abs(\n            track.idealY -\n              moveBy -\n              tracks[track.trackID].path[track.segmentID].y\n          ) * tracks[track.trackID].width;\n      }\n    });\n  });\n  return result;\n}\n\nfunction compareByIdealLane(a, b) {\n  if (a.hasOwnProperty('idealLane')) {\n    if (b.hasOwnProperty('idealLane')) {\n      if (a.idealLane < b.idealLane) return -1;\n      else if (a.idealLane > b.idealLane) return 1;\n      return 0;\n    }\n    return -1;\n  }\n  if (b.hasOwnProperty('idealLane')) {\n    return 1;\n  }\n  return 0;\n}\n\nfunction compareNodesByOrder(a, b) {\n  if (a === null) {\n    if (b === null) return 0;\n    return -1;\n  }\n  if (b === null) return 1;\n\n  if (a.hasOwnProperty('order')) {\n    if (b.hasOwnProperty('order')) {\n      if (a.order < b.order) return -1;\n      else if (a.order > b.order) return 1;\n      if (a.hasOwnProperty('y') && b.hasOwnProperty('y')) {\n        if (a.y < b.y) return -1;\n        else if (a.y > b.y) return 1;\n      }\n      return 0;\n    }\n    return -1;\n  }\n  if (b.hasOwnProperty('order')) return 1;\n  return 0;\n}\n\nfunction addTrackFeatures() {\n  let nodeStart;\n  let nodeEnd;\n  let feature = {};\n\n  bed.forEach(line => {\n    let i = 0;\n    while (i < numberOfTracks && tracks[i].name !== line.track) i += 1;\n    if (i < numberOfTracks) {\n      nodeStart = 0;\n      tracks[i].path.forEach(node => {\n        if (node.node !== null) {\n          feature = {};\n          if (nodes[node.node].hasOwnProperty('sequenceLength')) {\n            nodeEnd = nodeStart + nodes[node.node].sequenceLength - 1;\n          } else {\n            nodeEnd = nodeStart + nodes[node.node].width - 1;\n          }\n\n          if (nodeStart >= line.start && nodeStart <= line.end) {\n            feature.start = 0;\n          }\n          if (nodeStart < line.start && nodeEnd >= line.start) {\n            feature.start = line.start - nodeStart;\n          }\n          if (nodeEnd <= line.end && nodeEnd >= line.start) {\n            feature.end = nodeEnd - nodeStart;\n            if (nodeEnd < line.end) feature.continue = true;\n          }\n          if (nodeEnd > line.end && nodeStart <= line.end) {\n            feature.end = line.end - nodeStart;\n          }\n          if (feature.hasOwnProperty('start')) {\n            feature.type = line.type;\n            feature.name = line.name;\n            if (!node.hasOwnProperty('features')) node.features = [];\n            node.features.push(feature);\n          }\n          nodeStart = nodeEnd + 1;\n        }\n      });\n    }\n  });\n}\n\nfunction calculateTrackWidth() {\n  // flag: if vg returns freq of 0 for all tracks, we will increase width manually\n  let allAreFour = true;\n\n  tracks.forEach(track => {\n    if (track.hasOwnProperty('freq')) {\n      // custom track width\n      track.width = Math.round((Math.log(track.freq) + 1) * 4);\n    } else {\n      // default track width\n      track.width = 15;\n      if (track.hasOwnProperty('type') && track.type === 'read') {\n        track.width = 4;\n      }\n    }\n    if (track.width !== 4) {\n      allAreFour = false;\n    }\n  });\n\n  if (allAreFour) {\n    tracks.forEach(track => {\n      if (track.hasOwnProperty('freq')) {\n        track.width = 15;\n      }\n    });\n  }\n}\n\nexport function useColorScheme(x) {\n  config.colorScheme = x;\n  svg = d3.select(svgID);\n  const tr = createTubeMap();\n  if (!config.hideLegendFlag) drawLegend(tr);\n}\n\nfunction assignColorSets() {\n  haplotypeColors = getColorSet(config.haplotypeColors);\n  forwardReadColors = getColorSet(config.forwardReadColors);\n  reverseReadColors = getColorSet(config.reverseReadColors);\n  exonColors = getColorSet(config.exonColors);\n}\n\nfunction getColorSet(colorSetName) {\n  switch (colorSetName) {\n    case 'plainColors':\n      return plainColors;\n    case 'reds':\n      return reds;\n    case 'blues':\n      return blues;\n    case 'greys':\n      return greys;\n    case 'lightColors':\n      return lightColors;\n    default:\n      return greys;\n  }\n}\n\nfunction generateTrackColor(track, highlight) {\n  if (typeof highlight === 'undefined') highlight = 'plain';\n  let trackColor;\n  if (track.hasOwnProperty('type') && track.type === 'read') {\n    if (config.colorReadsByMappingQuality) {\n      trackColor = d3.interpolateRdYlGn(\n        Math.min(60, track.mapping_quality) / 60\n      );\n    } else {\n      if (track.hasOwnProperty('is_reverse') && track.is_reverse === true) {\n        trackColor = reverseReadColors[track.id % reverseReadColors.length];\n      } else {\n        trackColor = forwardReadColors[track.id % forwardReadColors.length];\n      }\n    }\n  } else {\n    if (config.showExonsFlag === false || highlight !== 'plain') {\n      trackColor = haplotypeColors[track.id % haplotypeColors.length];\n    } else {\n      trackColor = exonColors[track.id % exonColors.length];\n    }\n  }\n  return trackColor;\n}\n\nfunction getReadXStart(read) {\n  const node = nodes[read.path[0].node];\n  if (read.path[0].isForward) {\n    // read starts in forward direction\n    return getXCoordinateOfBaseWithinNode(node, read.firstNodeOffset);\n  }\n  // read starts in backward direction\n  return getXCoordinateOfBaseWithinNode(\n    node,\n    node.sequenceLength - read.firstNodeOffset\n  );\n}\n\nfunction getReadXEnd(read) {\n  const node = nodes[read.path[read.path.length - 1].node];\n  if (read.path[read.path.length - 1].isForward) {\n    // read ends in forward direction\n    return getXCoordinateOfBaseWithinNode(node, read.finalNodeCoverLength);\n  }\n  // read ends in backward direction\n  return getXCoordinateOfBaseWithinNode(\n    node,\n    node.sequenceLength - read.finalNodeCoverLength\n  );\n}\n\n// returns the x coordinate (in pixels) of (the left side) of the given base\n// position within the given node\nfunction getXCoordinateOfBaseWithinNode(node, base) {\n  if (base > node.sequenceLength) return null; // equality is allowed\n  const nodeLeftX = node.x - 4;\n  const nodeRightX = node.x + node.pixelWidth + 4;\n  return nodeLeftX + (base / node.sequenceLength) * (nodeRightX - nodeLeftX);\n}\n\n// transforms the info in the tracks' path attribute into actual coordinates\n// and saves them in trackRectangles and trackCurves\nfunction generateSVGShapesFromPath() {\n  let xStart;\n  let xEnd;\n  let yStart;\n  let yEnd;\n  let trackColor;\n  let highlight;\n  let dummy;\n  let reversalFlag;\n\n  for (let i = 0; i <= maxOrder; i += 1) {\n    extraLeft.push(0);\n    extraRight.push(0);\n  }\n\n  // generate x coords where each order starts and ends\n  const orderStartX = [];\n  const orderEndX = [];\n  nodes.forEach(node => {\n    if (node.hasOwnProperty('order')) {\n      orderStartX[node.order] = node.x;\n      if (orderEndX[node.order] === undefined) {\n        orderEndX[node.order] = node.x + node.pixelWidth;\n      } else {\n        orderEndX[node.order] = Math.max(\n          orderEndX[node.order],\n          node.x + node.pixelWidth\n        );\n      }\n    }\n  });\n\n  tracks.forEach(track => {\n    highlight = 'plain';\n    trackColor = generateTrackColor(track, highlight);\n\n    // start of path\n    yStart = track.path[0].y;\n    if (track.type !== 'read') {\n      if (track.sequence[0].charAt(0) === '-') {\n        // The track starts with an inversed node\n        xStart = orderEndX[track.path[0].order] + 20;\n      } else {\n        // The track starts with a forward node\n        xStart = orderStartX[track.path[0].order] - 20;\n      }\n    } else {\n      xStart = getReadXStart(track);\n    }\n\n    // middle of path\n    for (let i = 0; i < track.path.length; i += 1) {\n      if (track.path[i].y === yStart) {\n        if (track.path[i].hasOwnProperty('features')) {\n          reversalFlag =\n            i > 0 && track.path[i - 1].order === track.path[i].order;\n          dummy = createFeatureRectangle(\n            track.path[i],\n            orderStartX[track.path[i].order],\n            orderEndX[track.path[i].order],\n            highlight,\n            track,\n            xStart,\n            yStart,\n            trackColor,\n            reversalFlag\n          );\n          highlight = dummy.highlight;\n          xStart = dummy.xStart;\n        }\n      } else {\n        if (track.path[i - 1].isForward) {\n          xEnd = orderEndX[track.path[i - 1].order];\n        } else {\n          xEnd = orderStartX[track.path[i - 1].order];\n        }\n        if (xEnd !== xStart) {\n          trackColor = generateTrackColor(track, highlight);\n          trackRectangles.push({\n            xStart: Math.min(xStart, xEnd),\n            yStart,\n            xEnd: Math.max(xStart, xEnd),\n            yEnd: yStart + track.width - 1,\n            color: trackColor,\n            id: track.id,\n            type: track.type\n          });\n        }\n\n        if (track.path[i].order - 1 === track.path[i - 1].order) {\n          // regular forward connection\n          xStart = xEnd;\n          xEnd = orderStartX[track.path[i].order];\n          yEnd = track.path[i].y;\n          trackColor = generateTrackColor(track, highlight);\n          trackCurves.push({\n            xStart,\n            yStart,\n            xEnd: xEnd + 1,\n            yEnd,\n            width: track.width,\n            color: trackColor,\n            laneChange: Math.abs(track.path[i].lane - track.path[i - 1].lane),\n            id: track.id,\n            type: track.type\n          });\n          xStart = xEnd;\n          yStart = yEnd;\n        } else if (track.path[i].order + 1 === track.path[i - 1].order) {\n          // regular backward connection\n          xStart = xEnd;\n          xEnd = orderEndX[track.path[i].order];\n          yEnd = track.path[i].y;\n          trackColor = generateTrackColor(track, highlight);\n          trackCurves.push({\n            xStart: xStart + 1,\n            yStart,\n            xEnd,\n            yEnd,\n            width: track.width,\n            color: trackColor,\n            laneChange: Math.abs(track.path[i].lane - track.path[i - 1].lane),\n            id: track.id,\n            type: track.type\n          });\n          xStart = xEnd;\n          yStart = yEnd;\n        } else {\n          // change of direction\n          if (track.path[i - 1].isForward) {\n            yEnd = track.path[i].y;\n            generateForwardToReverse(\n              xEnd,\n              yStart,\n              yEnd,\n              track.width,\n              trackColor,\n              track.id,\n              track.path[i].order,\n              track.type\n            );\n            xStart = orderEndX[track.path[i].order];\n            yStart = track.path[i].y;\n          } else {\n            yEnd = track.path[i].y;\n            generateReverseToForward(\n              xEnd,\n              yStart,\n              yEnd,\n              track.width,\n              trackColor,\n              track.id,\n              track.path[i].order,\n              track.type\n            );\n            xStart = orderStartX[track.path[i].order];\n            yStart = track.path[i].y;\n          }\n        }\n\n        if (track.path[i].hasOwnProperty('features')) {\n          reversalFlag = track.path[i - 1].order === track.path[i].order;\n          dummy = createFeatureRectangle(\n            track.path[i],\n            orderStartX[track.path[i].order],\n            orderEndX[track.path[i].order],\n            highlight,\n            track,\n            xStart,\n            yStart,\n            trackColor,\n            reversalFlag\n          );\n          highlight = dummy.highlight;\n          xStart = dummy.xStart;\n        }\n      }\n    }\n\n    // ending edges\n    if (track.type !== 'read') {\n      if (!track.path[track.path.length - 1].isForward) {\n        // The track ends with an inversed node\n        xEnd = orderStartX[track.path[track.path.length - 1].order] - 20;\n      } else {\n        // The track ends with a forward node\n        xEnd = orderEndX[track.path[track.path.length - 1].order] + 20;\n      }\n    } else {\n      xEnd = getReadXEnd(track);\n    }\n    trackRectangles.push({\n      xStart: Math.min(xStart, xEnd),\n      yStart,\n      xEnd: Math.max(xStart, xEnd),\n      yEnd: yStart + track.width - 1,\n      color: trackColor,\n      id: track.id,\n      type: track.type\n    });\n  });\n}\n\nfunction createFeatureRectangle(\n  node,\n  nodeXStart,\n  nodeXEnd,\n  highlight,\n  track,\n  rectXStart,\n  yStart,\n  trackColor,\n  reversalFlag\n) {\n  let nodeWidth;\n  let currentHighlight = highlight;\n  let c;\n  let co;\n  let featureXStart;\n  let featureXEnd;\n\n  nodeXStart -= 8;\n  nodeXEnd += 8;\n  if (nodes[node.node].hasOwnProperty('sequenceLength')) {\n    nodeWidth = nodes[node.node].sequenceLength;\n  } else {\n    nodeWidth = nodes[node.node].width;\n  }\n\n  node.features.sort((a, b) => a.start - b.start);\n  node.features.forEach(feature => {\n    if (currentHighlight !== feature.type) {\n      // finish incoming rectangle\n      c = generateTrackColor(track, currentHighlight);\n      if (node.isForward === true) {\n        featureXStart =\n          nodeXStart +\n          Math.round((feature.start * (nodeXEnd - nodeXStart + 1)) / nodeWidth);\n\n        // overwrite narrow post-inversion rectangle if highlight starts near beginning of node\n        if (reversalFlag && featureXStart < nodeXStart + 8) {\n          featureXEnd =\n            nodeXStart +\n            Math.round(\n              ((feature.end + 1) * (nodeXEnd - nodeXStart + 1)) / nodeWidth\n            ) -\n            1;\n          co = generateTrackColor(track, feature.type);\n          trackRectanglesStep3.push({\n            xStart: featureXStart,\n            yStart,\n            xEnd: featureXEnd,\n            yEnd: yStart + track.width - 1,\n            color: co,\n            id: track.id,\n            type: track.type\n          });\n        }\n\n        if (featureXStart > rectXStart + 1) {\n          trackRectanglesStep3.push({\n            xStart: rectXStart,\n            yStart,\n            xEnd: featureXStart - 1,\n            yEnd: yStart + track.width - 1,\n            color: c,\n            id: track.id,\n            type: track.type\n          });\n        }\n      } else {\n        featureXStart =\n          nodeXEnd -\n          Math.round((feature.start * (nodeXEnd - nodeXStart + 1)) / nodeWidth);\n\n        // overwrite narrow post-inversion rectangle if highlight starts near beginning of node\n        if (reversalFlag && featureXStart > nodeXEnd - 8) {\n          featureXEnd =\n            nodeXEnd -\n            Math.round(\n              ((feature.end + 1) * (nodeXEnd - nodeXStart + 1)) / nodeWidth\n            ) -\n            1;\n          co = generateTrackColor(track, feature.type);\n          trackRectanglesStep3.push({\n            xStart: featureXEnd,\n            yStart,\n            xEnd: featureXStart,\n            yEnd: yStart + track.width - 1,\n            color: co,\n            id: track.id,\n            type: track.type\n          });\n        }\n\n        if (rectXStart > featureXStart + 1) {\n          trackRectanglesStep3.push({\n            xStart: featureXStart + 1,\n            yStart,\n            xEnd: rectXStart,\n            yEnd: yStart + track.width - 1,\n            color: c,\n            id: track.id,\n            type: track.type\n          });\n        }\n      }\n      rectXStart = featureXStart;\n      currentHighlight = feature.type;\n    }\n    if (feature.end < nodeWidth - 1 || !feature.hasOwnProperty('continue')) {\n      // finish internal rectangle\n      c = generateTrackColor(track, currentHighlight);\n      if (node.isForward === true) {\n        featureXEnd =\n          nodeXStart +\n          Math.round(\n            ((feature.end + 1) * (nodeXEnd - nodeXStart + 1)) / nodeWidth\n          ) -\n          1;\n        trackRectanglesStep3.push({\n          xStart: rectXStart,\n          yStart,\n          xEnd: featureXEnd,\n          yEnd: yStart + track.width - 1,\n          color: c,\n          id: track.id,\n          type: track.type\n        });\n      } else {\n        featureXEnd =\n          nodeXEnd -\n          Math.round(\n            ((feature.end + 1) * (nodeXEnd - nodeXStart + 1)) / nodeWidth\n          ) -\n          1;\n        trackRectanglesStep3.push({\n          xStart: featureXEnd,\n          yStart,\n          xEnd: rectXStart,\n          yEnd: yStart + track.width - 1,\n          color: c,\n          id: track.id,\n          type: track.type\n        });\n      }\n      rectXStart = featureXEnd + 1;\n      currentHighlight = 'plain';\n    }\n  });\n  return { xStart: rectXStart, highlight: currentHighlight };\n}\n\nfunction generateForwardToReverse(\n  x,\n  yStart,\n  yEnd,\n  trackWidth,\n  trackColor,\n  trackID,\n  order,\n  type\n) {\n  x += 10 * extraRight[order];\n  const yTop = Math.min(yStart, yEnd);\n  const yBottom = Math.max(yStart, yEnd);\n  const radius = 7;\n\n  trackVerticalRectangles.push({\n    // elongate incoming rectangle a bit to the right\n    xStart: x - 10 * extraRight[order],\n    yStart,\n    xEnd: x + 5,\n    yEnd: yStart + trackWidth - 1,\n    color: trackColor,\n    id: trackID,\n    type\n  });\n  trackVerticalRectangles.push({\n    // vertical rectangle\n    xStart: x + 5 + radius,\n    yStart: yTop + trackWidth + radius - 1,\n    xEnd: x + 5 + radius + Math.min(7, trackWidth) - 1,\n    yEnd: yBottom - radius + 1,\n    color: trackColor,\n    id: trackID,\n    type\n  });\n  trackVerticalRectangles.push({\n    xStart: x - 10 * extraRight[order],\n    yStart: yEnd,\n    xEnd: x + 5,\n    yEnd: yEnd + trackWidth - 1,\n    color: trackColor,\n    id: trackID,\n    type\n  }); // elongate outgoing rectangle a bit to the right\n\n  let d = `M ${x + 5} ${yBottom}`;\n  d += ` Q ${x + 5 + radius} ${yBottom} ${x + 5 + radius} ${yBottom - radius}`;\n  d += ` H ${x + 5 + radius + Math.min(7, trackWidth)}`;\n  d += ` Q ${x + 5 + radius + Math.min(7, trackWidth)} ${yBottom +\n    trackWidth} ${x + 5} ${yBottom + trackWidth}`;\n  d += ' Z ';\n  trackCorners.push({ path: d, color: trackColor, id: trackID, type });\n\n  d = `M ${x + 5} ${yTop}`;\n  d += ` Q ${x + 5 + radius + Math.min(7, trackWidth)} ${yTop} ${x +\n    5 +\n    radius +\n    Math.min(7, trackWidth)} ${yTop + trackWidth + radius}`;\n  d += ` H ${x + 5 + radius}`;\n  d += ` Q ${x + 5 + radius} ${yTop + trackWidth} ${x + 5} ${yTop +\n    trackWidth}`;\n  d += ' Z ';\n  trackCorners.push({ path: d, color: trackColor, id: trackID, type });\n  extraRight[order] += 1;\n}\n\nfunction generateReverseToForward(\n  x,\n  yStart,\n  yEnd,\n  trackWidth,\n  trackColor,\n  trackID,\n  order,\n  type\n) {\n  const yTop = Math.min(yStart, yEnd);\n  const yBottom = Math.max(yStart, yEnd);\n  const radius = 7;\n  x -= 10 * extraLeft[order];\n\n  trackVerticalRectangles.push({\n    xStart: x - 6,\n    yStart,\n    xEnd: x + 10 * extraLeft[order],\n    yEnd: yStart + trackWidth - 1,\n    color: trackColor,\n    id: trackID,\n    type\n  }); // elongate incoming rectangle a bit to the left\n  trackVerticalRectangles.push({\n    xStart: x - 5 - radius - Math.min(7, trackWidth),\n    yStart: yTop + trackWidth + radius - 1,\n    xEnd: x - 5 - radius - 1,\n    yEnd: yBottom - radius + 1,\n    color: trackColor,\n    id: trackID,\n    type\n  }); // vertical rectangle\n  trackVerticalRectangles.push({\n    xStart: x - 6,\n    yStart: yEnd,\n    xEnd: x + 10 * extraLeft[order],\n    yEnd: yEnd + trackWidth - 1,\n    color: trackColor,\n    id: trackID,\n    type\n  }); // elongate outgoing rectangle a bit to the left\n\n  // Path for bottom 90 degree bend\n  let d = `M ${x - 5} ${yBottom}`;\n  d += ` Q ${x - 5 - radius} ${yBottom} ${x - 5 - radius} ${yBottom - radius}`;\n  d += ` H ${x - 5 - radius - Math.min(7, trackWidth)}`;\n  d += ` Q ${x - 5 - radius - Math.min(7, trackWidth)} ${yBottom +\n    trackWidth} ${x - 5} ${yBottom + trackWidth}`;\n  d += ' Z ';\n  trackCorners.push({ path: d, color: trackColor, id: trackID, type });\n\n  // Path for top 90 degree bend\n  d = `M ${x - 5} ${yTop}`;\n  d += ` Q ${x - 5 - radius - Math.min(7, trackWidth)} ${yTop} ${x -\n    5 -\n    radius -\n    Math.min(7, trackWidth)} ${yTop + trackWidth + radius}`;\n  d += ` H ${x - 5 - radius}`;\n  d += ` Q ${x - 5 - radius} ${yTop + trackWidth} ${x - 5} ${yTop +\n    trackWidth}`;\n  d += ' Z ';\n  trackCorners.push({ path: d, color: trackColor, id: trackID, type });\n  extraLeft[order] += 1;\n}\n\n// to avoid problems with wrong overlapping of tracks, draw them in order of their color\nfunction drawReversalsByColor(corners, rectangles, type) {\n  if (typeof type === 'undefined') type = 'haplo';\n  const co = new Set();\n  rectangles.forEach(rect => {\n    co.add(rect.color);\n  });\n  co.forEach(c => {\n    drawTrackRectangles(\n      rectangles.filter(filterObjectByAttribute('color', c)),\n      type\n    );\n    drawTrackCorners(corners.filter(filterObjectByAttribute('color', c)), type);\n  });\n}\n\n// draws nodes by building svg-path for border and filling it with transparent white\nfunction drawNodes(dNodes) {\n  let x;\n  let y;\n\n  dNodes.forEach(node => {\n    // top left arc\n    node.d = `M ${node.x - 9} ${node.y} Q ${node.x - 9} ${node.y - 9} ${\n      node.x\n    } ${node.y - 9}`;\n    x = node.x;\n    y = node.y - 9;\n\n    // top straight\n    if (node.width > 1) {\n      x += node.pixelWidth;\n      node.d += ` L ${x} ${y}`;\n    }\n\n    // top right arc\n    node.d += ` Q ${x + 9} ${y} ${x + 9} ${y + 9}`;\n    x += 9;\n    y += 9;\n\n    // right straight\n    if (node.contentHeight > 0) {\n      y += node.contentHeight - 0;\n      node.d += ` L ${x} ${y}`;\n    }\n\n    // bottom right arc\n    node.d += ` Q ${x} ${y + 9} ${x - 9} ${y + 9}`;\n    x -= 9;\n    y += 9;\n\n    // bottom straight\n    if (node.width > 1) {\n      x -= node.pixelWidth;\n      node.d += ` L ${x} ${y}`;\n    }\n\n    // bottom left arc\n    node.d += ` Q ${x - 9} ${y} ${x - 9} ${y - 9}`;\n    x -= 9;\n    y -= 9;\n\n    // left straight\n    if (node.contentHeight > 0) {\n      y -= node.contentHeight - 0;\n      node.d += ` L ${x} ${y}`;\n    }\n  });\n\n  svg\n    .selectAll('.node')\n    .data(dNodes)\n    .enter()\n    .append('path')\n    .attr('id', d => d.name)\n    .attr('d', d => d.d)\n    .on('mouseover', nodeMouseOver)\n    .on('mouseout', nodeMouseOut)\n    .on('dblclick', nodeDoubleClick)\n    .style('fill', config.transparentNodesFlag ? 'none' : '#fff')\n    .style('fill-opacity', config.showExonsFlag ? '0.4' : '0.6')\n    .style('stroke', 'black')\n    .style('stroke-width', '2px')\n    .append('svg:title')\n    .text(d => getPopUpText(d));\n}\n\nfunction getPopUpText(node) {\n  return (\n    `Node ID: ${node.name}\\n` +\n    `Node Length: ${node.sequenceLength} bases\\n` +\n    `Haplotypes: ${node.degree}\\n` +\n    `Aligned Reads: ${node.incomingReads.length +\n      node.internalReads.length +\n      node.outgoingReads.length}`\n  );\n}\n\n// draw seqence labels for nodes\nfunction drawLabels(dNodes) {\n  if (config.nodeWidthOption === 0) {\n    svg\n      .selectAll('text')\n      .data(dNodes)\n      .enter()\n      .append('text')\n      .attr('x', d => d.x - 4)\n      .attr('y', d => d.y + 4)\n      .text(d => d.seq)\n      .attr('font-family', fonts)\n      .attr('font-size', '14px')\n      .attr('fill', 'black')\n      .style('pointer-events', 'none');\n  }\n}\n\nfunction drawRuler() {\n  let rulerTrackIndex = 0;\n  while (tracks[rulerTrackIndex].name !== trackForRuler) rulerTrackIndex += 1;\n  const rulerTrack = tracks[rulerTrackIndex];\n\n  // draw horizontal line\n  svg\n    .append('line')\n    .attr('x1', 0)\n    .attr('y1', minYCoordinate - 10)\n    .attr('x2', maxXCoordinate)\n    .attr('y2', minYCoordinate - 10)\n    .attr('stroke-width', 1)\n    .attr('stroke', 'black');\n\n  // How often should we have a tick in bp?\n  let markingInterval = 100;\n  if (config.nodeWidthOption === 0) markingInterval = 20;\n  // How close may markings be in image space?\n  const markingClearance = 80;\n  \n  // We need to call drawRulerMarking(base pair number, layout X coordinate)\n  // for each tick mark we want in our legend. But we can't just walk the path\n  // and X at the same time, placing ticks periodically because the ruler path\n  // isn't nexessarily used for the layout backbone, and can go all over the\n  // place, including backward through nodes. \n\n  // So we walk along the path, place ticks, and then drop the ones that are\n  // too close together.\n  \n  // This will hold pairs of base position, x coordinate.\n  let ticks = []\n  \n  // We keep a cursor to the start of the current node traversal along the path\n  let indexOfFirstBaseInNode = rulerTrack.indexOfFirstBase;\n  // And the next index along the path that doesn't have a mark but could.\n  let nextUnmarkedIndex = indexOfFirstBaseInNode;\n  \n  for (let i = 0; i < rulerTrack.indexSequence.length; i++) {\n    const nodeIndex = rulerTrack.indexSequence[i];\n    const currentNode = nodes[Math.abs(nodeIndex)];\n    // Each node may actually have the track go through it backward. In fact,\n    // the whole track may be laid out backward.\n    const currentNodeIsReverse = isReverse(rulerTrack.sequence[i]);\n    \n    // For some displayus we want to mark each node only once.\n    let alreadyMarkedNode = false;\n    \n    while (nextUnmarkedIndex < indexOfFirstBaseInNode + currentNode.sequenceLength) {\n      // We are thinking of marking a position on this node.\n    \n      // What base along our traversal of this node should we be marking?\n      let indexIntoVisitToMark = nextUnmarkedIndex - indexOfFirstBaseInNode;\n      \n      // What offset into the node should we mark at, relative to its forward-strand start?\n      let offsetIntoNodeForward = currentNodeIsReverse ?\n        // If going in reverse, take off bases of the node we use from the right side\n        currentNode.sequenceLength - 1 - indexIntoVisitToMark :\n        // Otherwise, add them to the left side\n        indexIntoVisitToMark;\n      \n      if (config.nodeWidthOption !== 0) {\n        // Actually always mark at an edge of the node, if we are scaling the node nonlinearly\n        offsetIntoNodeForward = currentNodeIsReverse ? currentNode.sequenceLength - 1 : 0;\n      }\n      \n      // Where should we mark in the visualization?\n      let xCoordOfMarking = getXCoordinateOfBaseWithinNode(currentNode, offsetIntoNodeForward);\n      \n      if (config.nodeWidthOption === 0 || !alreadyMarkedNode) {\n        // This is a mark we are not filtering due to node compression.\n        // Make the mark\n        ticks.push([indexOfFirstBaseInNode + indexIntoVisitToMark, xCoordOfMarking]);\n        alreadyMarkedNode = true;\n      }\n      \n      // Think about the next place along the path we care about.\n      nextUnmarkedIndex += markingInterval;\n    }\n    // Advance to the next node\n    indexOfFirstBaseInNode += currentNode.sequenceLength;\n  }\n  \n  // Sort ticks on X coordinate\n  ticks.sort(([bp1, x1], [bp2, x2]) => x1 > x2)\n  \n  // Filter ticks for a minimum X separartion\n  let separatedTicks = []\n  ticks.forEach(tick => {\n    if (separatedTicks.length === 0 || tick[1] - separatedTicks[separatedTicks.length - 1][1] >= markingClearance) {\n      // Take only the first tick or ticks far enough from the previous tick taken.\n      separatedTicks.push(tick);\n    }\n  })\n  ticks = separatedTicks;\n  \n  // Plot all the ticks\n  ticks.forEach(tick => drawRulerMarking(tick[0], tick[1]))\n  \n}\n\nfunction drawRulerMarking(sequencePosition, xCoordinate) {\n  svg\n    .append('text')\n    .attr('x', xCoordinate)\n    .attr('y', minYCoordinate - 13)\n    .text(`|${sequencePosition}`)\n    .attr('font-family', fonts)\n    .attr('font-size', '12px')\n    .attr('fill', 'black')\n    .style('pointer-events', 'none');\n}\n\nfunction filterObjectByAttribute(attribute, value) {\n  return item => item[attribute] === value;\n}\n\nfunction drawTrackRectangles(rectangles, type) {\n  if (typeof type === 'undefined') type = 'haplo';\n  rectangles = rectangles.filter(filterObjectByAttribute('type', type));\n\n  svg\n    .selectAll('trackRectangles')\n    .data(rectangles)\n    .enter()\n    .append('rect')\n    .attr('x', d => d.xStart)\n    .attr('y', d => d.yStart)\n    .attr('width', d => d.xEnd - d.xStart + 1)\n    .attr('height', d => d.yEnd - d.yStart + 1)\n    .style('fill', d => d.color)\n    .attr('trackID', d => d.id)\n    .attr('class', d => `track${d.id}`)\n    .attr('color', d => d.color)\n    .on('mouseover', trackMouseOver)\n    .on('mouseout', trackMouseOut)\n    .on('dblclick', trackDoubleClick);\n}\n\nfunction compareCurvesByLineChanges(a, b) {\n  if (a[6] < b[6]) return -1;\n  else if (a[6] > b[6]) return 1;\n  return 0;\n}\n\nfunction defineSVGPatterns() {\n  const defs = svg.append('defs');\n  let pattern = defs.append('pattern').attrs({\n    id: 'patternA',\n    width: '7',\n    height: '7',\n    patternUnits: 'userSpaceOnUse',\n    patternTransform: 'rotate(45)'\n  });\n\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '0', width: '7', height: '7', fill: '#FFFFFF' });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '0', width: '3', height: '3', fill: '#505050' });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '4', width: '3', height: '3', fill: '#505050' });\n  pattern\n    .append('rect')\n    .attrs({ x: '4', y: '0', width: '3', height: '3', fill: '#505050' });\n  pattern\n    .append('rect')\n    .attrs({ x: '4', y: '4', width: '3', height: '3', fill: '#505050' });\n\n  pattern = defs.append('pattern').attrs({\n    id: 'patternB',\n    width: '8',\n    height: '8',\n    patternUnits: 'userSpaceOnUse',\n    patternTransform: 'rotate(45)'\n  });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '0', width: '8', height: '8', fill: '#FFFFFF' });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '0', width: '3', height: '3', fill: '#1f77b4' });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '5', width: '3', height: '3', fill: '#1f77b4' });\n  pattern\n    .append('rect')\n    .attrs({ x: '5', y: '0', width: '3', height: '3', fill: '#1f77b4' });\n  pattern\n    .append('rect')\n    .attrs({ x: '5', y: '5', width: '3', height: '3', fill: '#1f77b4' });\n\n  pattern = defs.append('pattern').attrs({\n    id: 'plaid0',\n    width: '6',\n    height: '6',\n    patternUnits: 'userSpaceOnUse',\n    patternTransform: 'rotate(45)'\n  });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '0', width: '6', height: '6', fill: '#FFFFFF' });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '0', width: '2', height: '2', fill: '#1f77b4' });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '4', width: '2', height: '2', fill: '#1f77b4' });\n  pattern\n    .append('rect')\n    .attrs({ x: '4', y: '0', width: '2', height: '2', fill: '#1f77b4' });\n  pattern\n    .append('rect')\n    .attrs({ x: '4', y: '4', width: '2', height: '2', fill: '#1f77b4' });\n\n  pattern = defs.append('pattern').attrs({\n    id: 'plaid1',\n    width: '6',\n    height: '6',\n    patternUnits: 'userSpaceOnUse',\n    patternTransform: 'rotate(45)'\n  });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '0', width: '6', height: '6', fill: '#FFFFFF' });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '0', width: '2', height: '2', fill: '#ff7f0e' });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '4', width: '2', height: '2', fill: '#ff7f0e' });\n  pattern\n    .append('rect')\n    .attrs({ x: '4', y: '0', width: '2', height: '2', fill: '#ff7f0e' });\n  pattern\n    .append('rect')\n    .attrs({ x: '4', y: '4', width: '2', height: '2', fill: '#ff7f0e' });\n\n  pattern = defs.append('pattern').attrs({\n    id: 'plaid2',\n    width: '6',\n    height: '6',\n    patternUnits: 'userSpaceOnUse',\n    patternTransform: 'rotate(45)'\n  });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '0', width: '6', height: '6', fill: '#FFFFFF' });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '0', width: '2', height: '2', fill: '#2ca02c' });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '4', width: '2', height: '2', fill: '#2ca02c' });\n  pattern\n    .append('rect')\n    .attrs({ x: '4', y: '0', width: '2', height: '2', fill: '#2ca02c' });\n  pattern\n    .append('rect')\n    .attrs({ x: '4', y: '4', width: '2', height: '2', fill: '#2ca02c' });\n\n  pattern = defs.append('pattern').attrs({\n    id: 'plaid3',\n    width: '6',\n    height: '6',\n    patternUnits: 'userSpaceOnUse',\n    patternTransform: 'rotate(45)'\n  });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '0', width: '6', height: '6', fill: '#FFFFFF' });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '0', width: '2', height: '2', fill: '#d62728' });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '4', width: '2', height: '2', fill: '#d62728' });\n  pattern\n    .append('rect')\n    .attrs({ x: '4', y: '0', width: '2', height: '2', fill: '#d62728' });\n  pattern\n    .append('rect')\n    .attrs({ x: '4', y: '4', width: '2', height: '2', fill: '#d62728' });\n\n  pattern = defs.append('pattern').attrs({\n    id: 'plaid4',\n    width: '6',\n    height: '6',\n    patternUnits: 'userSpaceOnUse',\n    patternTransform: 'rotate(45)'\n  });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '0', width: '6', height: '6', fill: '#FFFFFF' });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '0', width: '2', height: '2', fill: '#9467bd' });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '4', width: '2', height: '2', fill: '#9467bd' });\n  pattern\n    .append('rect')\n    .attrs({ x: '4', y: '0', width: '2', height: '2', fill: '#9467bd' });\n  pattern\n    .append('rect')\n    .attrs({ x: '4', y: '4', width: '2', height: '2', fill: '#9467bd' });\n\n  pattern = defs.append('pattern').attrs({\n    id: 'plaid5',\n    width: '6',\n    height: '6',\n    patternUnits: 'userSpaceOnUse',\n    patternTransform: 'rotate(45)'\n  });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '0', width: '6', height: '6', fill: '#FFFFFF' });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '0', width: '2', height: '2', fill: '#8c564b' });\n  pattern\n    .append('rect')\n    .attrs({ x: '0', y: '4', width: '2', height: '2', fill: '#8c564b' });\n  pattern\n    .append('rect')\n    .attrs({ x: '4', y: '0', width: '2', height: '2', fill: '#8c564b' });\n  pattern\n    .append('rect')\n    .attrs({ x: '4', y: '4', width: '2', height: '2', fill: '#8c564b' });\n}\n\nfunction drawTrackCurves(type) {\n  if (typeof type === 'undefined') type = 'haplo';\n  const myTrackCurves = trackCurves.filter(\n    filterObjectByAttribute('type', type)\n  );\n\n  myTrackCurves.sort(compareCurvesByLineChanges);\n\n  myTrackCurves.forEach(curve => {\n    const xMiddle = (curve.xStart + curve.xEnd) / 2;\n    let d = `M ${curve.xStart} ${curve.yStart}`;\n    d += ` C ${xMiddle} ${curve.yStart} ${xMiddle} ${curve.yEnd} ${\n      curve.xEnd\n    } ${curve.yEnd}`;\n    d += ` V ${curve.yEnd + curve.width}`;\n    d += ` C ${xMiddle} ${curve.yEnd + curve.width} ${xMiddle} ${curve.yStart +\n      curve.width} ${curve.xStart} ${curve.yStart + curve.width}`;\n    d += ' Z';\n    curve.path = d;\n  });\n\n  svg\n    .selectAll('trackCurves')\n    .data(trackCurves)\n    .enter()\n    .append('path')\n    .attr('d', d => d.path)\n    .style('fill', d => d.color)\n    .attr('trackID', d => d.id)\n    .attr('class', d => `track${d.id}`)\n    .attr('color', d => d.color)\n    .on('mouseover', trackMouseOver)\n    .on('mouseout', trackMouseOut)\n    .on('dblclick', trackDoubleClick);\n}\n\nfunction drawTrackCorners(corners, type) {\n  if (typeof type === 'undefined') type = 'haplo';\n  corners = corners.filter(filterObjectByAttribute('type', type));\n\n  svg\n    .selectAll('trackCorners')\n    .data(corners)\n    .enter()\n    .append('path')\n    .attr('d', d => d.path)\n    .style('fill', d => d.color)\n    .attr('trackID', d => d.id)\n    .attr('class', d => `track${d.id}`)\n    .attr('color', d => d.color)\n    .on('mouseover', trackMouseOver)\n    .on('mouseout', trackMouseOut)\n    .on('dblclick', trackDoubleClick);\n}\n\nfunction drawLegend() {\n  let content =\n    '<table class=\"table-sm table-condensed table-nonfluid\"><thead><tr><th>Color</th><th>Trackname</th><th>Show Track</th></tr></thead>';\n  const listeners = [];\n  for (let i = 0; i < tracks.length; i += 1) {\n    if (tracks[i].type === 'haplo') {\n      content += `<tr><td style=\"text-align:right\"><div class=\"color-box\" style=\"background-color: ${generateTrackColor(\n        tracks[i],\n        'exon'\n      )};\"></div></td>`;\n      if (tracks[i].hasOwnProperty('name')) {\n        content += `<td>${tracks[i].name}</td>`;\n      } else {\n        content += `<td>${tracks[i].id}</td>`;\n      }\n      content += `<td><input type=\"checkbox\" checked=true id=\"showTrack${i}\"></td>`;\n      listeners.push(i);\n    }\n  }\n  content += '</table';\n  // $('#legendDiv').html(content);\n  document.getElementById('legendDiv').innerHTML = content;\n  listeners.forEach(i => {\n    document\n      .getElementById(`showTrack${i}`)\n      .addEventListener('click', () => changeTrackVisibility(i), false);\n  });\n}\n\n// Highlight track on mouseover\nfunction trackMouseOver() {\n  /* jshint validthis: true */\n  const trackID = d3.select(this).attr('trackID');\n  d3.selectAll(`.track${trackID}`).style('fill', 'url(#patternA)');\n}\n\n// Highlight node on mouseover\nfunction nodeMouseOver() {\n  /* jshint validthis: true */\n  d3.select(this).style('stroke-width', '4px');\n}\n\n// Restore original track appearance on mouseout\nfunction trackMouseOut() {\n  /* jshint validthis: true */\n  const trackID = d3.select(this).attr('trackID');\n  d3.selectAll(`.track${trackID}`).each(function clearTrackHighlight() {\n    const c = d3.select(this).attr('color');\n    d3.select(this).style('fill', c);\n  });\n}\n\n// Restore original node appearance on mouseout\nfunction nodeMouseOut() {\n  /* jshint validthis: true */\n  d3.select(this).style('stroke-width', '2px');\n}\n\n// Move clicked track to first position\nfunction trackDoubleClick() {\n  /* jshint validthis: true */\n  const trackID = d3.select(this).attr('trackID');\n  let index = 0;\n  while (\n    index < inputTracks.length &&\n    inputTracks[index].id !== Number(trackID)\n  ) {\n    index += 1;\n  }\n  if (index >= inputTracks.length) return;\n  if (DEBUG) console.log(`moving index: ${index}`);\n  moveTrackToFirstPosition(index);\n  createTubeMap();\n}\n\n// Redraw with current node moved to beginning\nfunction nodeDoubleClick() {\n  /* jshint validthis: true */\n  const nodeID = d3.select(this).attr('id');\n  if (config.clickableNodesFlag) {\n    if (reads && config.showReads) {\n      document.getElementById('hgvmNodeID').value = nodeID;\n      document.getElementById('hgvmPostButton').click();\n    } else {\n      document.getElementById('nodeID').value = nodeID;\n      document.getElementById('postButton').click();\n    }\n  }\n}\n\n// extract info about nodes from vg-json\nexport function vgExtractNodes(vg) {\n  const result = [];\n  vg.node.forEach(node => {\n    result.push({\n      name: `${node.id}`,\n      sequenceLength: node.sequence.length,\n      seq: node.sequence\n    });\n  });\n  return result;\n}\n\n// calculate node widths depending on sequence lengths and chosen calculation method\nfunction generateNodeWidth() {\n  nodes.forEach(node => {\n    if (!node.hasOwnProperty('sequenceLength')) {\n      node.sequenceLength = node.seq.length;\n    }\n  });\n\n  switch (config.nodeWidthOption) {\n    case 1:\n      nodes.forEach(node => {\n        node.width = 1 + Math.log(node.sequenceLength) / Math.log(2);\n        node.pixelWidth = Math.round((node.width - 1) * 8.401);\n      });\n      break;\n    case 2:\n      nodes.forEach(node => {\n        node.width = node.sequenceLength / 100;\n        node.pixelWidth = Math.round((node.width - 1) * 8.401);\n      });\n      break;\n    default:\n      nodes.forEach(node => {\n        node.width = node.sequenceLength;\n\n        // get width of node's text label by writing label, measuring it and removing label\n        svg\n          .append('text')\n          .attr('x', 0)\n          .attr('y', 100)\n          .attr('id', 'dummytext')\n          .text(node.seq.substr(1))\n          .attr('font-family', fonts)\n          .attr('font-size', '14px')\n          .attr('fill', 'black')\n          .style('pointer-events', 'none');\n        let element = document.getElementById('dummytext');\n        if (element.getComputedTextLength) {\n          // We are on a platform where text length computation is possible (i.e. a real browser)\n          node.pixelWidth = Math.round(element.getComputedTextLength());\n        }\n        document.getElementById('dummytext').remove();\n      });\n  }\n}\n\n// extract track info from vg-json\nexport function vgExtractTracks(vg) {\n  const result = [];\n  vg.path.forEach((path, index) => {\n    const sequence = [];\n    path.mapping.forEach(pos => {\n      if (\n        pos.position.hasOwnProperty('is_reverse') &&\n        pos.position.is_reverse === true\n      ) {\n        sequence.push(reverse(`${pos.position.node_id}`));\n      } else {\n        sequence.push(`${pos.position.node_id}`);\n      }\n    });\n    const track = {};\n    track.id = index;\n    track.sequence = sequence;\n    if (path.hasOwnProperty('freq')) track.freq = path.freq;\n    if (path.hasOwnProperty('name')) track.name = path.name;\n    if (path.hasOwnProperty('indexOfFirstBase')) {\n      track.indexOfFirstBase = Number(path.indexOfFirstBase);\n    }\n    result.push(track);\n  });\n  return result;\n}\n\nfunction compareReadsByLeftEnd(a, b) {\n  let leftNodeA;\n  let leftNodeB;\n  let leftIndexA;\n  let leftIndexB;\n\n  if (isReverse(a.sequence[0])) {\n    if (isReverse(a.sequence[a.sequence.length - 1])) {\n      leftNodeA = forward(a.sequence[a.sequence.length - 1]);\n      leftIndexA =\n        nodes[nodeMap.get(leftNodeA)].sequenceLength - a.finalNodeCoverLength;\n    } else {\n      leftNodeA = a.sequence[a.sequence.length - 1];\n      leftIndexA = 0;\n    }\n  } else {\n    leftNodeA = a.sequence[0];\n    leftIndexA = a.firstNodeOffset;\n  }\n\n  if (isReverse(b.sequence[0])) {\n    if (isReverse(b.sequence[b.sequence.length - 1])) {\n      leftNodeB = forward(b.sequence[b.sequence.length - 1]);\n      leftIndexB =\n        nodes[nodeMap.get(leftNodeB)].sequenceLength - b.finalNodeCoverLength;\n    } else {\n      leftNodeB = b.sequence[b.sequence.length - 1];\n      leftIndexB = 0;\n    }\n  } else {\n    leftNodeB = b.sequence[0];\n    leftIndexB = b.firstNodeOffset;\n  }\n\n  if (leftNodeA < leftNodeB) return -1;\n  else if (leftNodeA > leftNodeB) return 1;\n  if (leftIndexA < leftIndexB) return -1;\n  else if (leftIndexA > leftIndexB) return 1;\n  return 0;\n}\n\nfunction compareReadsByLeftEnd2(a, b) {\n  // compare by order of first node\n  if (nodes[Math.abs(a.indexSequence[0])].order < nodes[Math.abs(b.indexSequence[0])].order) {\n    return -1;\n  } else if (\n    nodes[Math.abs(a.indexSequence[0])].order > nodes[Math.abs(b.indexSequence[0])].order\n  ) {\n    return 1;\n  }\n\n  // compare by first base within first node\n  if (a.firstNodeOffset < b.firstNodeOffset) return -1;\n  else if (a.firstNodeOffset > b.firstNodeOffset) return 1;\n\n  // compare by order of last node\n  if (\n    nodes[Math.abs(a.indexSequence[a.indexSequence.length - 1])].order <\n    nodes[Math.abs(b.indexSequence[b.indexSequence.length - 1])].order\n  ) {\n    return -1;\n  } else if (\n    nodes[Math.abs(a.indexSequence[a.indexSequence.length - 1])].order >\n    nodes[Math.abs(b.indexSequence[b.indexSequence.length - 1])].order\n  ) {\n    return 1;\n  }\n\n  // compare by last base withing last node\n  if (a.finalNodeCoverLength < b.finalNodeCoverLength) return -1;\n  else if (a.finalNodeCoverLength > b.finalNodeCoverLength) return 1;\n\n  return 0;\n}\n\nexport function vgExtractReads(myNodes, myTracks, myReads) {\n  if (DEBUG) {\n    console.log('Reads:');\n    console.log(myReads);\n  }\n  const extracted = [];\n\n  const nodeNames = [];\n  myNodes.forEach(node => {\n    nodeNames.push(node.name, 10);\n  });\n\n  for (let i = 0; i < myReads.length; i += 1) {\n    const read = myReads[i];\n    const sequence = [];\n    const sequenceNew = [];\n    let firstIndex = -1; // index within mapping of the first node id contained in nodeNames\n    let lastIndex = -1; // index within mapping of the last node id contained in nodeNames\n    read.path.mapping.forEach((pos, j) => {\n      if (nodeNames.indexOf(pos.position.node_id) > -1) {\n        const edit = {};\n        let offset = 0;\n        if (\n          pos.position.hasOwnProperty('is_reverse') &&\n          pos.position.is_reverse === true\n        ) {\n          sequence.push(reverse(`${pos.position.node_id}`));\n          edit.nodeName = reverse(`${pos.position.node_id}`);\n        } else {\n          sequence.push(`${pos.position.node_id}`);\n          edit.nodeName = pos.position.node_id.toString();\n        }\n        if (firstIndex < 0) {\n          firstIndex = j;\n          if (pos.position.hasOwnProperty('offset')) {\n            pos.position.offset = parseInt(pos.position.offset, 10);\n            offset = pos.position.offset;\n          }\n        }\n        lastIndex = j;\n\n        const mismatches = [];\n        let posWithinNode = offset;\n        pos.edit.forEach(element => {\n          if (\n            element.hasOwnProperty('to_length') &&\n            !element.hasOwnProperty('from_length')\n          ) {\n            // insertion\n            mismatches.push({\n              type: 'insertion',\n              pos: posWithinNode,\n              seq: element.sequence\n            });\n          } else if (\n            !element.hasOwnProperty('to_length') &&\n            element.hasOwnProperty('from_length')\n          ) {\n            // deletion\n            mismatches.push({\n              type: 'deletion',\n              pos: posWithinNode,\n              length: element.from_length\n            });\n          } else if (element.hasOwnProperty('sequence')) {\n            // substitution\n            if (element.sequence.length > 1) {\n              if (DEBUG) {\n                console.log(\n                  `found substitution at read ${i}, node ${j} = ${\n                    pos.position.node_id\n                  }, seq = ${element.sequence}`\n                );\n              }\n            }\n            mismatches.push({\n              type: 'substitution',\n              pos: posWithinNode,\n              seq: element.sequence\n            });\n          }\n          if (element.hasOwnProperty('from_length')) {\n            posWithinNode += element.from_length;\n          }\n        });\n        edit.mismatches = mismatches;\n        sequenceNew.push(edit);\n      }\n    });\n    if (sequence.length === 0) {\n      if (DEBUG) {\n        console.log(`read ${i} is empty`);\n      }\n    } else {\n      const track = {};\n      track.id = myTracks.length + extracted.length;\n      track.sequence = sequence;\n      track.sequenceNew = sequenceNew;\n      track.type = 'read';\n      if (read.path.hasOwnProperty('freq')) track.freq = read.path.freq;\n      if (read.path.hasOwnProperty('name')) track.name = read.path.name;\n\n      // where within node does read start\n      track.firstNodeOffset = 0;\n      if (read.path.mapping[firstIndex].position.hasOwnProperty('offset')) {\n        track.firstNodeOffset = read.path.mapping[firstIndex].position.offset;\n      }\n\n      // where within node does read end\n      const finalNodeEdit = read.path.mapping[lastIndex].edit;\n      track.finalNodeCoverLength = 0;\n      if (read.path.mapping[lastIndex].position.hasOwnProperty('offset')) {\n        track.finalNodeCoverLength +=\n          read.path.mapping[lastIndex].position.offset;\n      }\n      finalNodeEdit.forEach(edit => {\n        if (edit.hasOwnProperty('from_length')) {\n          track.finalNodeCoverLength += edit.from_length;\n        }\n      });\n\n      track.mapping_quality = read.mapping_quality || 0;\n      track.is_secondary = read.is_secondary || false;\n\n      extracted.push(track);\n    }\n  }\n  return extracted;\n}\n\n// remove redundant nodes\n// two nodes A and B can be merged if all tracks leaving A go directly into B\n// and all tracks entering B come directly from A\n// (plus no inversions involved)\nfunction mergeNodes() {\n  let nodeName;\n  let nodeName2;\n  const pred = []; // array of set of predecessors of each node\n  const succ = []; // array of set of successors of each node\n  for (let i = 0; i < nodes.length; i += 1) {\n    pred.push(new Set());\n    succ.push(new Set());\n  }\n\n  let tracksAndReads;\n  if (reads && config.showReads) tracksAndReads = tracks.concat(reads);\n  else tracksAndReads = tracks;\n\n  tracksAndReads.forEach(track => {\n    for (let i = 0; i < track.sequence.length; i += 1) {\n      if (!isReverse(track.sequence[i])) {\n        // forward Node\n        if (i > 0) {\n          nodeName = track.sequence[i - 1];\n          pred[nodeMap.get(track.sequence[i])].add(nodeName);\n          if (isReverse(nodeName)) {\n            // add 2 predecessors, to make sure there is no node merging in this case\n            pred[nodeMap.get(track.sequence[i])].add(forward(nodeName));\n          }\n        } else if (track.type === 'haplo') {\n          pred[nodeMap.get(track.sequence[i])].add('None');\n        }\n        if (i < track.sequence.length - 1) {\n          nodeName = track.sequence[i + 1];\n          succ[nodeMap.get(track.sequence[i])].add(nodeName);\n          if (isReverse(nodeName)) {\n            // add 2 successors, to make sure there is no node merging in this case\n            succ[nodeMap.get(track.sequence[i])].add(forward(nodeName));\n          }\n        } else if (track.type === 'haplo') {\n          succ[nodeMap.get(track.sequence[i])].add('None');\n        }\n      } else {\n        // reverse Node\n        nodeName = forward(track.sequence[i]);\n        if (i > 0) {\n          nodeName2 = track.sequence[i - 1];\n          if (isReverse(nodeName2)) {\n            succ[nodeMap.get(nodeName)].add(forward(nodeName2));\n          } else {\n            // add 2 successors, to make sure there is no node merging in this case\n            succ[nodeMap.get(nodeName)].add(nodeName2);\n            succ[nodeMap.get(nodeName)].add(reverse(nodeName2));\n          }\n        } else if (track.type === 'haplo') {\n          succ[nodeMap.get(nodeName)].add('None');\n        }\n        if (i < track.sequence.length - 1) {\n          nodeName2 = track.sequence[i + 1];\n          if (isReverse(nodeName2)) {\n            pred[nodeMap.get(nodeName)].add(forward(nodeName2));\n          } else {\n            pred[nodeMap.get(nodeName)].add(nodeName2);\n            pred[nodeMap.get(nodeName)].add(reverse(nodeName2));\n          }\n        } else if (track.type === 'haplo') {\n          pred[nodeMap.get(nodeName)].add('None');\n        }\n      }\n    }\n  });\n\n  // convert sets to arrays\n  for (let i = 0; i < nodes.length; i += 1) {\n    succ[i] = Array.from(succ[i]);\n    pred[i] = Array.from(pred[i]);\n  }\n\n  // update reads which pass through merging nodes\n  if (reads && config.showReads) {\n    // sort nodes by order, then by y-coordinate\n    const sortedNodes = nodes.slice();\n    sortedNodes.sort(compareNodesByOrder);\n\n    // iterate over all nodes and calculate their position within the new merged node\n    const mergeOffset = new Map();\n    const mergeOrigin = new Map(); // maps to leftmost node of a node's \"merging cascade\"\n    sortedNodes.forEach(node => {\n      const predecessor = mergeableWithPred(nodeMap.get(node.name), pred, succ);\n      if (predecessor) {\n        mergeOffset.set(\n          node.name,\n          mergeOffset.get(predecessor) +\n            nodes[nodeMap.get(predecessor)].sequenceLength\n        );\n        mergeOffset.set(\n          '-' + node.name,\n          mergeOffset.get(predecessor) +\n            nodes[nodeMap.get(predecessor)].sequenceLength\n        );\n        mergeOrigin.set(node.name, mergeOrigin.get(predecessor));\n        mergeOrigin.set(reverse(node.name), mergeOrigin.get(predecessor));\n      } else {\n        mergeOffset.set(node.name, 0);\n        mergeOffset.set(reverse(node.name), 0);\n        mergeOrigin.set(node.name, node.name);\n        mergeOrigin.set(reverse(node.name), node.name);\n      }\n    });\n\n    reads.forEach(read => {\n      read.firstNodeOffset += mergeOffset.get(read.sequence[0]);\n      read.finalNodeCoverLength += mergeOffset.get(\n        read.sequence[read.sequence.length - 1]\n      );\n      for (let i = read.sequence.length - 1; i >= 0; i -= 1) {\n        const nodeName = forward(read.sequence[i]);\n        if (mergeableWithPred(nodeMap.get(nodeName), pred, succ)) {\n          const predecessor = mergeableWithPred(\n            nodeMap.get(nodeName),\n            pred,\n            succ\n          );\n          if (mergeableWithSucc(nodeMap.get(predecessor), pred, succ)) {\n            if (i > 0) {\n              read.sequence.splice(i, 1);\n              // adjust position of mismatches\n              read.sequenceNew[i].mismatches.forEach(mismatch => {\n                mismatch.pos += nodes[nodeMap.get(predecessor)].sequenceLength;\n              });\n              // append mismatches to previous entry's mismatches\n              read.sequenceNew[i - 1].mismatches = read.sequenceNew[\n                i - 1\n              ].mismatches.concat(read.sequenceNew[i].mismatches);\n              read.sequenceNew.splice(i, 1);\n            } else {\n              read.sequence[0] = mergeOrigin.get(read.sequence[0]);\n              read.sequenceNew[i].mismatches.forEach(mismatch => {\n                mismatch.pos += mergeOffset.get(read.sequenceNew[0].nodeName);\n              });\n              read.sequenceNew[0].nodeName = mergeOrigin.get(\n                read.sequenceNew[0].nodeName\n              );\n            }\n          }\n        }\n      }\n    });\n  }\n\n  // update node sequences + sequence lengths\n  for (let i = 0; i < nodes.length; i += 1) {\n    if (mergeableWithSucc(i, pred, succ) && !mergeableWithPred(i, pred, succ)) {\n      let donor = i;\n      while (mergeableWithSucc(donor, pred, succ)) {\n        donor = forward(succ[donor][0]);\n        donor = nodeMap.get(donor);\n        if (nodes[i].hasOwnProperty('sequenceLength')) {\n          nodes[i].sequenceLength += nodes[donor].sequenceLength;\n        } else {\n          nodes[i].width += nodes[donor].width;\n        }\n        nodes[i].seq += nodes[donor].seq;\n      }\n    }\n  }\n\n  // actually merge the nodes by removing the corresponding nodes from track data\n  tracks.forEach(track => {\n    for (let i = track.sequence.length - 1; i >= 0; i -= 1) {\n      nodeName = forward(track.sequence[i]);\n      const nodeIndex = nodeMap.get(nodeName);\n      if (mergeableWithPred(nodeIndex, pred, succ)) {\n        track.sequence.splice(i, 1);\n      }\n    }\n  });\n\n  // remove the nodes from node-array\n  for (let i = nodes.length - 1; i >= 0; i -= 1) {\n    if (mergeableWithPred(i, pred, succ)) {\n      nodes.splice(i, 1);\n    }\n  }\n}\n\nfunction mergeableWithPred(index, pred, succ) {\n  if (pred[index].length !== 1) return false;\n  if (pred[index][0] === 'None') return false;\n  let predecessor = forward(pred[index][0]);\n  const predecessorIndex = nodeMap.get(predecessor);\n  if (succ[predecessorIndex].length !== 1) return false;\n  if (succ[predecessorIndex][0] === 'None') return false;\n  return predecessor;\n}\n\nfunction mergeableWithSucc(index, pred, succ) {\n  if (succ[index].length !== 1) return false;\n  if (succ[index][0] === 'None') return false;\n  let successor = forward(succ[index][0]);\n  const successorIndex = nodeMap.get(successor);\n  if (pred[successorIndex].length !== 1) return false;\n  if (pred[successorIndex][0] === 'None') return false;\n  return true;\n}\n\nfunction drawMismatches() {\n  tracks.forEach((read, trackIdx) => {\n    if (read.type === 'read') {\n      read.sequenceNew.forEach((element, i) => {\n        element.mismatches.forEach(mm => {\n          const nodeName = forward(element.nodeName);\n          const nodeIndex = nodeMap.get(nodeName);\n          const node = nodes[nodeIndex];\n          const x = getXCoordinateOfBaseWithinNode(node, mm.pos);\n          let pathIndex = i;\n          while (read.path[pathIndex].node !== nodeIndex) {\n            pathIndex += 1;\n          }\n          const y = read.path[pathIndex].y;\n          if (mm.type === 'insertion') {\n            if (\n              config.showSoftClips ||\n              ((mm.pos !== read.firstNodeOffset || i !== 0) &&\n                (mm.pos !== read.finalNodeCoverLength ||\n                  i !== read.sequenceNew.length - 1))\n            ) {\n              drawInsertion(x - 3, y + 7, mm.seq, node.y);\n            }\n          } else if (mm.type === 'deletion') {\n            const x2 = getXCoordinateOfBaseWithinNode(node, mm.pos + mm.length);\n            drawDeletion(x, x2, y + 4, node.y);\n          } else if (mm.type === 'substitution') {\n            const x2 = getXCoordinateOfBaseWithinNode(\n              node,\n              mm.pos + mm.seq.length\n            );\n            drawSubstitution(x + 1, x2, y + 7, node.y, mm.seq);\n          }\n        });\n      });\n    }\n  });\n}\n\nfunction drawInsertion(x, y, seq, nodeY) {\n  svg\n    .append('text')\n    .attr('x', x)\n    .attr('y', y)\n    .text('*')\n    .attr('font-family', fonts)\n    .attr('font-size', '12px')\n    .attr('fill', 'black')\n    .attr('nodeY', nodeY)\n    .on('mouseover', insertionMouseOver)\n    .on('mouseout', insertionMouseOut)\n    .append('svg:title')\n    .text(seq);\n}\n\nfunction drawSubstitution(x1, x2, y, nodeY, seq) {\n  svg\n    .append('text')\n    .attr('x', x1)\n    .attr('y', y)\n    .text(seq)\n    .attr('font-family', fonts)\n    .attr('font-size', '12px')\n    .attr('fill', 'black')\n    .attr('nodeY', nodeY)\n    .attr('rightX', x2)\n    .on('mouseover', substitutionMouseOver)\n    .on('mouseout', substitutionMouseOut);\n}\n\nfunction drawDeletion(x1, x2, y, nodeY) {\n  // draw horizontal block\n  svg\n    .append('line')\n    .attr('x1', x1)\n    .attr('y1', y - 1)\n    .attr('x2', x2)\n    .attr('y2', y - 1)\n    .attr('stroke-width', 7)\n    .attr('stroke', 'grey')\n    .attr('nodeY', nodeY)\n    .on('mouseover', deletionMouseOver)\n    .on('mouseout', deletionMouseOut);\n}\n\nfunction insertionMouseOver() {\n  /* jshint validthis: true */\n  d3.select(this).attr('fill', 'red');\n  const x = Number(d3.select(this).attr('x'));\n  const y = Number(d3.select(this).attr('y'));\n  const yTop = Number(d3.select(this).attr('nodeY'));\n  svg\n    .append('line')\n    .attr('class', 'insertionHighlight')\n    .attr('x1', x + 4)\n    .attr('y1', y - 10)\n    .attr('x2', x + 4)\n    .attr('y2', yTop + 5)\n    .attr('stroke-width', 1)\n    .attr('stroke', 'black');\n}\n\nfunction deletionMouseOver() {\n  /* jshint validthis: true */\n  d3.select(this).attr('stroke', 'red');\n  const x1 = Number(d3.select(this).attr('x1'));\n  const x2 = Number(d3.select(this).attr('x2'));\n  const y = Number(d3.select(this).attr('y1'));\n  const yTop = Number(d3.select(this).attr('nodeY'));\n  svg\n    .append('line')\n    .attr('class', 'deletionHighlight')\n    .attr('x1', x1)\n    .attr('y1', y - 3)\n    .attr('x2', x1)\n    .attr('y2', yTop + 5)\n    .attr('stroke-width', 1)\n    .attr('stroke', 'black');\n  svg\n    .append('line')\n    .attr('class', 'deletionHighlight')\n    .attr('x1', x2)\n    .attr('y1', y - 3)\n    .attr('x2', x2)\n    .attr('y2', yTop + 5)\n    .attr('stroke-width', 1)\n    .attr('stroke', 'black');\n}\n\nfunction substitutionMouseOver() {\n  /* jshint validthis: true */\n  d3.select(this).attr('fill', 'red');\n  const x1 = Number(d3.select(this).attr('x'));\n  const x2 = Number(d3.select(this).attr('rightX'));\n  const y = Number(d3.select(this).attr('y'));\n  const yTop = Number(d3.select(this).attr('nodeY'));\n  svg\n    .append('line')\n    .attr('class', 'substitutionHighlight')\n    .attr('x1', x1 - 1)\n    .attr('y1', y - 7)\n    .attr('x2', x1 - 1)\n    .attr('y2', yTop + 5)\n    .attr('stroke-width', 1)\n    .attr('stroke', 'black');\n  svg\n    .append('line')\n    .attr('class', 'substitutionHighlight')\n    .attr('x1', x2 + 1)\n    .attr('y1', y - 7)\n    .attr('x2', x2 + 1)\n    .attr('y2', yTop + 5)\n    .attr('stroke-width', 1)\n    .attr('stroke', 'black');\n}\n\nfunction insertionMouseOut() {\n  /* jshint validthis: true */\n  d3.select(this).attr('fill', 'black');\n  d3.selectAll('.insertionHighlight').remove();\n}\n\nfunction deletionMouseOut() {\n  /* jshint validthis: true */\n  d3.select(this).attr('stroke', 'grey');\n  d3.selectAll('.deletionHighlight').remove();\n}\n\nfunction substitutionMouseOut() {\n  /* jshint validthis: true */\n  d3.select(this).attr('fill', 'black');\n  d3.selectAll('.substitutionHighlight').remove();\n}\n\nfunction filterReads(reads) {\n  if (!reads) return reads;\n  return reads.filter(\n    read =>\n      !read.is_secondary && read.mapping_quality >= config.mappingQualityCutoff\n  );\n}\n","export const dataOriginTypes = {\n  API: 'API',\n  EXAMPLE_1: 'example 1',\n  EXAMPLE_2: 'example 2',\n  EXAMPLE_3: 'example 3',\n  EXAMPLE_4: 'example 4',\n  EXAMPLE_5: 'example 5',\n  EXAMPLE_6: 'example 6'\n};\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Form, Label, Input, Button } from 'reactstrap';\nimport { FontAwesomeIcon } from '@fortawesome/react-fontawesome';\nimport {\n  faStepBackward,\n  faStepForward,\n  faSearchPlus,\n  faSearchMinus\n} from '@fortawesome/free-solid-svg-icons';\nimport * as tubeMap from '../util/tubemap';\n\nconst ZOOM_FACTOR = 2.0;\n\nclass DataPositionFormRow extends Component {\n  handleZoomIn = () => {\n    tubeMap.zoomBy(ZOOM_FACTOR);\n  };\n\n  handleZoomOut = () => {\n    tubeMap.zoomBy(1.0 / ZOOM_FACTOR);\n  };\n\n  handleDownloadButton = () => {\n    const svgN = document.getElementById('svg');\n    const svgData = new XMLSerializer().serializeToString(svgN);\n    const svgBlob = new Blob([svgData], {\n      type: 'image/svg+xml;charset=utf-8'\n    });\n    const svgUrl = URL.createObjectURL(svgBlob);\n\n    const downloadLink = document.createElement('a');\n    downloadLink.href = svgUrl;\n    downloadLink.download = 'graph.svg';\n    document.body.appendChild(downloadLink);\n    downloadLink.click();\n    document.body.removeChild(downloadLink);\n  };\n\n  render() {\n    return (\n      <Form inline>\n        <Label className=\"tight-label mb-2 mr-sm-2 mb-sm-0 ml-2\" for=\"nodeID\">\n          Start:\n        </Label>\n        <Input\n          type=\"text\"\n          className=\"custom-input form-control mb-2 mr-sm-4 mb-sm-0\"\n          id=\"nodeID\"\n          size=\"12\"\n          value={this.props.nodeID}\n          onChange={this.props.handleInputChange}\n        />\n        <Label className=\"tight-label mb-2 mr-sm-2 mb-sm-0 ml-2\" for=\"distance\">\n          Length:\n        </Label>\n        <Input\n          type=\"text\"\n          className=\"custom-input form-control mb-2 mr-sm-2 mb-sm-0\"\n          id=\"distance\"\n          size=\"4\"\n          value={this.props.distance}\n          onChange={this.props.handleInputChange}\n        />\n        <Label\n          className=\"tight-label mb-2 mr-sm-2 mb-sm-0 ml-2\"\n          for=\"byNode\"\n        >\n          Unit:\n        </Label>\n        <Input\n          type=\"select\"\n          className=\"custom-select mb-2 mr-sm-2 mb-sm-0\"\n          id=\"byNode\"\n          value={this.props.byNode}\n          onChange={this.props.handleInputChange}\n        >\n          <option value=\"false\">Nucleotides</option>\n          <option value=\"true\">Nodes</option>\n        </Input>\n        &nbsp;\n        {this.props.uploadInProgress && (\n          <div className=\"smallLoader\" id=\"fileUploadSpinner\" />\n        )}\n        <Button\n          color=\"primary\"\n          id=\"goButton\"\n          onClick={this.props.handleGoButton}\n          disabled={this.props.uploadInProgress}\n        >\n          Go\n        </Button>\n        <Button\n          color=\"primary\"\n          id=\"goLeftButton\"\n          onClick={this.props.handleGoLeft}\n        >\n          <FontAwesomeIcon icon={faStepBackward} size=\"lg\" />\n        </Button>\n        <Button color=\"primary\" id=\"zoomInButton\" onClick={this.handleZoomIn}>\n          <FontAwesomeIcon icon={faSearchPlus} size=\"lg\" />\n        </Button>\n        <Button color=\"primary\" id=\"zoomOutButton\" onClick={this.handleZoomOut}>\n          <FontAwesomeIcon icon={faSearchMinus} size=\"lg\" />\n        </Button>\n        <Button\n          color=\"primary\"\n          id=\"goRightButton\"\n          onClick={this.props.handleGoRight}\n        >\n          <FontAwesomeIcon icon={faStepForward} size=\"lg\" />\n        </Button>\n        <Button\n          color=\"secondary\"\n          id=\"downloadButton\"\n          onClick={this.handleDownloadButton}\n        >\n          Download Image\n        </Button>\n      </Form>\n    );\n  }\n}\n\nDataPositionFormRow.propTypes = {\n  byNode: PropTypes.oneOf(['true', 'false']).isRequired,\n  distance: PropTypes.string.isRequired, \n  handleGoButton: PropTypes.func.isRequired,\n  handleGoLeft: PropTypes.func.isRequired,\n  handleGoRight: PropTypes.func.isRequired,\n  handleInputChange: PropTypes.func.isRequired,\n  nodeID: PropTypes.string.isRequired,\n  uploadInProgress: PropTypes.bool.isRequired,\n};\n\nexport default DataPositionFormRow;\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Label, Input } from 'reactstrap';\n\nclass MountedDataFormRow extends Component {\n  render() {\n    const xgFileDropdownOptions = this.props.xgSelectOptions.map(fileName => {\n      return (\n        <option value={fileName} key={fileName}>\n          {fileName}\n        </option>\n      );\n    });\n\n    const gbwtFileDropdownOptions = this.props.gbwtSelectOptions.map(\n      fileName => {\n        return (\n          <option value={fileName} key={fileName}>\n            {fileName}\n          </option>\n        );\n      }\n    );\n\n    const gamFileDropdownOptions = this.props.gamSelectOptions.map(fileName => {\n      return (\n        <option value={fileName} key={fileName}>\n          {fileName}\n        </option>\n      );\n    });\n\n    const pathDropdownOptions = this.props.pathSelectOptions.map(pathName => {\n      return (\n        <option value={pathName} key={pathName}>\n          {pathName}\n        </option>\n      );\n    });\n\n    return (\n      <React.Fragment>\n        <Label className=\"customData tight-label mb-2 mr-sm-2 mb-sm-0 ml-2\">\n          xg file:\n        </Label>\n        <Input\n          type=\"select\"\n          className=\"customDataMounted custom-select mb-2 mr-sm-4 mb-sm-0\"\n          id=\"xgSelect\"\n          value={this.props.xgSelect}\n          onChange={this.props.handleInputChange}\n        >\n          {xgFileDropdownOptions}\n        </Input>\n\n        <Label\n          for=\"gbwtFileSelect\"\n          className=\"customData tight-label mb-2 mr-sm-2 mb-sm-0 ml-2\"\n        >\n          gbwt file:\n        </Label>\n        <Input\n          type=\"select\"\n          className=\"customDataMounted custom-select mb-2 mr-sm-4 mb-sm-0\"\n          id=\"gbwtSelect\"\n          value={this.props.gbwtSelect}\n          onChange={this.props.handleInputChange}\n        >\n          {gbwtFileDropdownOptions}\n        </Input>\n\n        <Label\n          for=\"gamFileSelect\"\n          className=\"customData tight-label mb-2 mr-sm-2 mb-sm-0 ml-2\"\n        >\n          gam index:\n        </Label>\n        <Input\n          type=\"select\"\n          className=\"customDataMounted custom-select mb-2 mr-sm-4 mb-sm-0\"\n          id=\"gamSelect\"\n          value={this.props.gamSelect}\n          onChange={this.props.handleInputChange}\n        >\n          {gamFileDropdownOptions}\n        </Input>\n\n        <Label\n          for=\"pathName\"\n          className=\"customData tight-label mb-2 mr-sm-2 mb-sm-0 ml-2\"\n        >\n          Path name:\n        </Label>\n        <Input\n          type=\"select\"\n          className=\"customData custom-select mb-2 mr-sm-4 mb-sm-0\"\n          id=\"pathSelect\"\n          value={this.props.pathSelect}\n          onChange={this.props.handleInputChange}\n        >\n          {pathDropdownOptions}\n        </Input>\n      </React.Fragment>\n    );\n  }\n}\n\nMountedDataFormRow.propTypes = {\n  gamSelect: PropTypes.string.isRequired,\n  gamSelectOptions: PropTypes.array.isRequired,\n  gbwtSelect: PropTypes.string.isRequired,\n  gbwtSelectOptions: PropTypes.array.isRequired,\n  handleInputChange: PropTypes.func.isRequired,\n  pathSelect: PropTypes.string.isRequired,\n  pathSelectOptions: PropTypes.array.isRequired,\n  xgSelect: PropTypes.string.isRequired,\n  xgSelectOptions: PropTypes.array.isRequired\n};\n\nexport default MountedDataFormRow;\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Label, Input } from 'reactstrap';\n\nconst MAX_UPLOAD_SIZE = 5242880;\n\nclass FileUploadFormRow extends Component {\n  constructor(props) {\n    super(props);\n    this.xgFileInput = React.createRef();\n    this.gbwtFileInput = React.createRef();\n    this.gamFileInput = React.createRef();\n  }\n\n  onXgFileChange = () => {\n    const file = this.xgFileInput.current.files[0];\n    if (file === undefined) {\n      this.props.resetPathNames();\n      this.props.handleFileUpload('xgFile', 'none');\n    } else {\n      if (file.size > MAX_UPLOAD_SIZE) {\n        this.xgFileInput.current.value = '';\n        this.props.showFileSizeAlert();\n        return;\n      }\n      this.props.setUploadInProgress(true);\n      const formData = new FormData();\n      formData.append('xgFile', file);\n      const xhr = new XMLHttpRequest();\n      xhr.responseType = 'json';\n      xhr.onreadystatechange = () => {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n          // Every thing ok, file uploaded\n          this.props.setUploadInProgress(false);\n          this.props.handleFileUpload('xgFile', xhr.response.path);\n          this.props.getPathNames(xhr.response.path, 'true');\n        }\n      };\n      xhr.open('POST', `${this.props.apiUrl}/xgFileSubmission`, true);\n      xhr.send(formData);\n    }\n  };\n\n  onGbwtFileChange = () => {\n    const file = this.gbwtFileInput.current.files[0];\n    if (file === undefined) {\n      this.props.handleFileUpload('gbwtFile', 'none');\n    } else {\n      if (file.size > MAX_UPLOAD_SIZE) {\n        this.gbwtFileInput.current.value = '';\n        this.props.showFileSizeAlert();\n        return;\n      }\n      this.props.setUploadInProgress(true);\n      const formData = new FormData();\n      formData.append('gbwtFile', file);\n      const xhr = new XMLHttpRequest();\n      xhr.responseType = 'json';\n      xhr.onreadystatechange = () => {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n          // Every thing ok, file uploaded\n          this.props.setUploadInProgress(false);\n          this.props.handleFileUpload('gbwtFile', xhr.response.path);\n        }\n      };\n      xhr.open('POST', `${this.props.apiUrl}/gbwtFileSubmission`, true);\n      xhr.send(formData);\n    }\n  };\n\n  onGamFileChange = () => {\n    const file = this.gamFileInput.current.files[0];\n    if (file === undefined) {\n      this.props.handleFileUpload('gamFile', 'none');\n    } else {\n      if (file.size > MAX_UPLOAD_SIZE) {\n        this.gamFileInput.current.value = '';\n        this.props.showFileSizeAlert();\n        return;\n      }\n      this.props.setUploadInProgress(true);\n      const formData = new FormData();\n      formData.append('gamFile', file);\n      const xhr = new XMLHttpRequest();\n      xhr.responseType = 'json';\n      xhr.onreadystatechange = () => {\n        if (xhr.readyState === 4 && xhr.status === 200) {\n          // Every thing ok, file uploaded\n          this.props.setUploadInProgress(false);\n          this.props.handleFileUpload('gamFile', xhr.response.path);\n        }\n      };\n      xhr.open('POST', `${this.props.apiUrl}/gamFileSubmission`, true);\n      xhr.send(formData);\n    }\n  };\n\n  render() {\n    const pathDropdownOptions = this.props.pathSelectOptions.map(pathName => {\n      return (\n        <option value={pathName} key={pathName}>\n          {pathName}\n        </option>\n      );\n    });\n\n    return (\n      <React.Fragment>\n        <Label className=\"customData tight-label mb-2 mr-sm-2 mb-sm-0 ml-2\">\n          xg file:\n        </Label>\n        <Input\n          type=\"file\"\n          className=\"customDataUpload form-control-file\"\n          id=\"xgFileUpload\"\n          accept=\".xg\"\n          innerRef={this.xgFileInput}\n          onChange={this.onXgFileChange}\n        />\n        <Label\n          for=\"gbwtFileSelect\"\n          className=\"customData tight-label mb-2 mr-sm-2 mb-sm-0 ml-2\"\n        >\n          gbwt file:\n        </Label>\n        <Input\n          type=\"file\"\n          className=\"customDataUpload form-control-file\"\n          id=\"gbwtFileUpload\"\n          accept=\".gbwt\"\n          innerRef={this.gbwtFileInput}\n          onChange={this.onGbwtFileChange}\n        />\n        <Label\n          for=\"gamFileSelect\"\n          className=\"customData tight-label mb-2 mr-sm-2 mb-sm-0 ml-2\"\n        >\n          gam index:\n        </Label>\n        <Input\n          type=\"file\"\n          className=\"customDataUpload form-control-file\"\n          id=\"gamFileUpload\"\n          accept=\".gam\"\n          innerRef={this.gamFileInput}\n          onChange={this.onGamFileChange}\n        />\n        <Label\n          for=\"pathName\"\n          className=\"customData tight-label mb-2 mr-sm-2 mb-sm-0 ml-2\"\n        >\n          Path name:\n        </Label>\n        <Input\n          type=\"select\"\n          className=\"customData custom-select mb-2 mr-sm-4 mb-sm-0\"\n          id=\"pathSelect\"\n          value={this.props.pathSelect}\n          onChange={this.props.handleInputChange}\n        >\n          {pathDropdownOptions}\n        </Input>\n      </React.Fragment>\n    );\n  }\n}\n\nFileUploadFormRow.propTypes = {\n  apiUrl: PropTypes.string.isRequired,\n  getPathNames: PropTypes.func.isRequired,\n  handleFileUpload: PropTypes.func.isRequired,\n  handleInputChange: PropTypes.func.isRequired,\n  pathSelect: PropTypes.string.isRequired, \n  pathSelectOptions: PropTypes.array.isRequired, \n  resetPathNames: PropTypes.func.isRequired,\n  setUploadInProgress: PropTypes.func.isRequired,\n  showFileSizeAlert: PropTypes.func.isRequired\n};\n\nexport default FileUploadFormRow;\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Form, Button } from 'reactstrap';\nimport { dataOriginTypes } from '../enums';\n\nclass ExampleSelectButtons extends Component {\n  handleClick = (dataOrigin, haploColor, readColor) => {\n    this.props.setDataOrigin(dataOrigin);\n    this.props.setColorSetting('haplotypeColors', haploColor);\n    if (readColor) {\n      this.props.setColorSetting('forwardReadColors', readColor);\n    }\n  };\n\n  render() {\n    return (\n      <Form inline>\n        <Button\n          color=\"primary\"\n          id=\"example1\"\n          onClick={() =>\n            this.handleClick(dataOriginTypes.EXAMPLE_1, 'plainColors')\n          }\n        >\n          Indels and Polymorphisms only\n        </Button>\n        <Button\n          color=\"primary\"\n          id=\"example2\"\n          onClick={() =>\n            this.handleClick(dataOriginTypes.EXAMPLE_2, 'plainColors')\n          }\n        >\n          Inversions\n        </Button>\n        <Button\n          color=\"primary\"\n          id=\"example3\"\n          onClick={() =>\n            this.handleClick(dataOriginTypes.EXAMPLE_3, 'plainColors')\n          }\n        >\n          Nested Inversions\n        </Button>\n        <Button\n          color=\"primary\"\n          id=\"example4\"\n          onClick={() =>\n            this.handleClick(dataOriginTypes.EXAMPLE_4, 'plainColors')\n          }\n        >\n          Duplications\n        </Button>\n        <Button\n          color=\"primary\"\n          id=\"example5\"\n          onClick={() =>\n            this.handleClick(dataOriginTypes.EXAMPLE_5, 'plainColors')\n          }\n        >\n          Translocations\n        </Button>\n        <Button\n          color=\"primary\"\n          id=\"example6\"\n          onClick={() =>\n            this.handleClick(dataOriginTypes.EXAMPLE_6, 'greys', 'reds')\n          }\n        >\n          Aligned Reads\n        </Button>\n      </Form>\n    );\n  }\n}\n\nExampleSelectButtons.propTypes = {\n  setColorSetting: PropTypes.func.isRequired,\n  setDataOrigin: PropTypes.func.isRequired\n};\n\nexport default ExampleSelectButtons;\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Container, Row, Col, Form, Label, Input, Alert } from 'reactstrap';\nimport { dataOriginTypes } from '../enums';\n// import defaultConfig from '../config.default.json';\nimport config from '../config.json';\nimport DataPositionFormRow from './DataPositionFormRow';\nimport MountedDataFormRow from './MountedDataFormRow';\nimport FileUploadFormRow from './FileUploadFormRow';\nimport ExampleSelectButtons from './ExampleSelectButtons';\n\nconst DATA_SOURCES = config.DATA_SOURCES;\nconst MAX_UPLOAD_SIZE_DESCRIPTION = '5 MB';\nconst dataTypes = {\n  BUILT_IN: 'built-in',\n  FILE_UPLOAD: 'file-upload',\n  MOUNTED_FILES: 'mounted files',\n  EXAMPLES: 'examples'\n};\n\nclass HeaderForm extends Component {\n  state = {\n    xgSelectOptions: ['none'],\n    xgSelect: 'none',\n\n    gbwtSelectOptions: ['none'],\n    gbwtSelect: 'none',\n\n    gamSelectOptions: ['none'],\n    gamSelect: 'none',\n\n    pathSelectOptions: ['none'],\n    pathSelect: 'none',\n\n    xgFile: 'snp1kg-BRCA1.vg.xg',\n    gbwtFile: '',\n    gamFile: 'NA12878-BRCA1.sorted.gam',\n    anchorTrackName: '17',\n    dataPath: 'default',\n\n    nodeID: '1',\n    distance: '100',\n    byNode: 'false',\n\n    dataType: dataTypes.BUILT_IN,\n    fileSizeAlert: false,\n    uploadInProgress: false\n  };\n\n  componentDidMount() {\n    this.getMountedFilenames();\n    this.setUpWebsocket();\n  }\n\n  getMountedFilenames = async () => {\n    try {\n      const response = await fetch(`${this.props.apiUrl}/getFilenames`, {\n        method: 'GET',\n        headers: {\n          'Content-Type': 'application/json'\n        }\n      });\n      const json = await response.json();\n      json.xgFiles.unshift('none');\n      json.gbwtFiles.unshift('none');\n      json.gamIndices.unshift('none');\n\n      this.setState(state => {\n        const xgSelect = json.xgFiles.includes(state.xgSelect)\n          ? state.xgSelect\n          : 'none';\n        const gbwtSelect = json.gbwtFiles.includes(state.gbwtSelect)\n          ? state.gbwtSelect\n          : 'none';\n        const gamSelect = json.gamIndices.includes(state.gamSelect)\n          ? state.gamSelect\n          : 'none';\n        return {\n          xgSelectOptions: json.xgFiles,\n          gbwtSelectOptions: json.gbwtFiles,\n          gamSelectOptions: json.gamIndices,\n          xgSelect,\n          gbwtSelect,\n          gamSelect\n        };\n      });\n    } catch (error) {\n      console.log(`GET to ${this.props.apiUrl}/getFilenames failed:`, error);\n    }\n  };\n\n  getPathNames = async (xgFile, isUploadedFile) => {\n    try {\n      const response = await fetch(`${this.props.apiUrl}/getPathNames`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify({ xgFile, isUploadedFile })\n      });\n      const json = await response.json();\n      this.setState(state => {\n        const pathSelect = json.pathNames.includes(state.pathSelect)\n          ? state.pathSelect\n          : json.pathNames[0];\n        return {\n          pathSelectOptions: json.pathNames,\n          pathSelect,\n          anchorTrackName: pathSelect\n        };\n      });\n    } catch (error) {\n      console.log(`POST to ${this.props.apiUrl}/getPathNames failed:`, error);\n    }\n  };\n\n  resetPathNames = () => {\n    this.setState({\n      pathSelectOptions: ['none'],\n      pathSelect: 'none'\n    });\n  };\n\n  handleDataSourceChange = event => {\n    const value = event.target.value;\n    DATA_SOURCES.forEach(ds => {\n      if (ds.name === value) {\n        this.setState({\n          xgFile: ds.xgFile,\n          gbwtFile: ds.gbwtFile,\n          gamFile: ds.gamFile,\n          anchorTrackName: ds.anchorTrackName,\n          dataPath: ds.useMountedPath ? 'mounted' : 'default',\n          nodeID: ds.defaultPosition,\n          dataType: dataTypes.BUILT_IN\n        });\n        return;\n      }\n    });\n    if (value === 'customFileUpload') {\n      this.setState(state => {\n        return {\n          xgFile: state.xgSelect,\n          gbwtFile: state.gbwtSelect,\n          gamFile: state.gamSelect,\n          anchorTrackName: state.pathSelect,\n          dataPath: 'upload',\n          dataType: dataTypes.FILE_UPLOAD\n        };\n      });\n    } else if (value === 'customMounted') {\n      this.setState(state => {\n        return {\n          xgFile: state.xgSelect,\n          gbwtFile: state.gbwtSelect,\n          gamFile: state.gamSelect,\n          anchorTrackName: state.pathSelect,\n          dataPath: 'mounted',\n          dataType: dataTypes.MOUNTED_FILES\n        };\n      });\n    } else if (value === 'syntheticExamples') {\n      this.setState({ dataType: dataTypes.EXAMPLES });\n    }\n  };\n\n  handleGoButton = () => {\n    if (this.props.dataOrigin !== dataOriginTypes.API) {\n      this.props.setColorSetting('haplotypeColors', 'greys');\n      this.props.setColorSetting('forwardReadColors', 'reds');\n    }\n    const fetchParams = {\n      nodeID: this.state.nodeID,\n      distance: this.state.distance,\n      byNode: this.state.byNode,\n      xgFile: this.state.xgFile,\n      gbwtFile: this.state.gbwtFile,\n      gamFile: this.state.gamFile,\n      anchorTrackName: this.state.anchorTrackName,\n      dataPath: this.state.dataPath\n    };\n    this.props.setFetchParams(fetchParams);\n  };\n\n  handleInputChange = event => {\n    const id = event.target.id;\n    const value = event.target.value;\n    this.setState({ [id]: value });\n    if (id === 'xgSelect') {\n      this.getPathNames(value, false);\n      this.setState({ xgFile: value });\n    } else if (id === 'gbwtSelect') {\n      this.setState({ gbwtFile: value });\n    } else if (id === 'gamSelect') {\n      this.setState({ gamFile: value });\n    } else if (id === 'pathSelect') {\n      this.setState({ anchorTrackName: value });\n    }\n  };\n\n  handleGoRight = () => {\n    this.setState(\n      state => ({\n        nodeID: Number(this.state.nodeID) + Number(this.state.distance)\n      }),\n      () => this.handleGoButton()\n    );\n  };\n\n  handleGoLeft = () => {\n    this.setState(\n      state => ({\n        nodeID: Math.max(\n          0,\n          Number(this.state.nodeID) - Number(this.state.distance)\n        )\n      }),\n      () => this.handleGoButton()\n    );\n  };\n\n  handleFileUpload = (fileType, fileName) => {\n    this.setState({ [fileType]: fileName });\n  };\n\n  showFileSizeAlert = () => {\n    this.setState({ fileSizeAlert: true });\n  };\n\n  setUploadInProgress = val => {\n    this.setState({ uploadInProgress: val });\n  };\n\n  setUpWebsocket = () => {\n    this.ws = new WebSocket(this.props.apiUrl.replace(/^http/, 'ws'));\n    this.ws.onmessage = message => {\n      this.getMountedFilenames();\n    };\n    this.ws.onclose = event => {\n      setTimeout(this.setUpWebsocket, 1000);\n    };\n    this.ws.onerror = event => {\n      this.ws.close();\n    };\n  };\n\n  render() {\n    let dataSourceDropdownOptions = DATA_SOURCES.map(ds => {\n      return (\n        <option value={ds.name} key={ds.name}>\n          {ds.name}\n        </option>\n      );\n    });\n    dataSourceDropdownOptions.push(\n      <option value=\"syntheticExamples\" key=\"syntheticExamples\">\n        synthetic data examples\n      </option>,\n      <option value=\"customFileUpload\" key=\"customFileUpload\">\n        custom (file upload)\n      </option>,\n      <option value=\"customMounted\" key=\"customMounted\">\n        custom (mounted files)\n      </option>\n    );\n\n    const mountedFilesFlag = this.state.dataType === dataTypes.MOUNTED_FILES;\n    const uploadFilesFlag = this.state.dataType === dataTypes.FILE_UPLOAD;\n    const examplesFlag = this.state.dataType === dataTypes.EXAMPLES;\n\n    return (\n      <div>\n        <Container fluid={true}>\n          <Row>\n            <Col md=\"auto\">\n              <img src=\"./logo.png\" alt=\"Logo\" />\n            </Col>\n            <Col>\n              <Form inline>\n                <Label\n                  className=\"tight-label mb-2 mr-sm-2 mb-sm-0 ml-2\"\n                  for=\"dataSourceSelect\"\n                >\n                  Data:\n                </Label>\n                <Input\n                  type=\"select\"\n                  id=\"dataSourceSelect\"\n                  className=\"custom-select mb-2 mr-sm-4 mb-sm-0\"\n                  onChange={this.handleDataSourceChange}\n                >\n                  {dataSourceDropdownOptions}\n                </Input>\n                {mountedFilesFlag && (\n                  <MountedDataFormRow\n                    xgSelect={this.state.xgSelect}\n                    xgSelectOptions={this.state.xgSelectOptions}\n                    gbwtSelect={this.state.gbwtSelect}\n                    gbwtSelectOptions={this.state.gbwtSelectOptions}\n                    gamSelect={this.state.gamSelect}\n                    gamSelectOptions={this.state.gamSelectOptions}\n                    pathSelect={this.state.pathSelect}\n                    pathSelectOptions={this.state.pathSelectOptions}\n                    handleInputChange={this.handleInputChange}\n                  />\n                )}\n                {uploadFilesFlag && (\n                  <FileUploadFormRow\n                    apiUrl={this.props.apiUrl}\n                    pathSelect={this.state.pathSelect}\n                    pathSelectOptions={this.state.pathSelectOptions}\n                    handleInputChange={this.handleInputChange}\n                    getPathNames={this.getPathNames}\n                    resetPathNames={this.resetPathNames}\n                    handleFileUpload={this.handleFileUpload}\n                    showFileSizeAlert={this.showFileSizeAlert}\n                    setUploadInProgress={this.setUploadInProgress}\n                  />\n                )}\n              </Form>\n              <Alert\n                color=\"danger\"\n                isOpen={this.state.fileSizeAlert}\n                toggle={() => {\n                  this.setState({ fileSizeAlert: false });\n                }}\n                className=\"mt-3\"\n              >\n                <strong>File size too big! </strong>\n                You may only upload files with a maximum size of{' '}\n                {MAX_UPLOAD_SIZE_DESCRIPTION}.\n              </Alert>\n              {examplesFlag ? (\n                <ExampleSelectButtons\n                  setDataOrigin={this.props.setDataOrigin}\n                  setColorSetting={this.props.setColorSetting}\n                />\n              ) : (\n                <DataPositionFormRow\n                  nodeID={this.state.nodeID}\n                  distance={this.state.distance}\n                  byNode={this.state.byNode}\n                  handleInputChange={this.handleInputChange}\n                  handleGoLeft={this.handleGoLeft}\n                  handleGoRight={this.handleGoRight}\n                  handleGoButton={this.handleGoButton}\n                  uploadInProgress={this.state.uploadInProgress}\n                />\n              )}\n            </Col>\n          </Row>\n        </Container>\n      </div>\n    );\n  }\n}\n\nHeaderForm.propTypes = {\n  apiUrl: PropTypes.string.isRequired,\n  dataOrigin: PropTypes.string.isRequired,\n  setColorSetting: PropTypes.func.isRequired,\n  setDataOrigin: PropTypes.func.isRequired,\n  setFetchParams: PropTypes.func.isRequired\n};\n\nexport default HeaderForm;\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport * as tubeMap from '../util/tubemap';\n\nclass TubeMap extends Component {\n  componentDidMount() {\n    this.createTubeMap();\n  }\n\n  componentDidUpdate() {\n    this.createTubeMap();\n  }\n\n  createTubeMap = () => {\n    tubeMap.create({\n      svgID: '#svg',\n      nodes: this.props.nodes,\n      tracks: this.props.tracks,\n      reads: this.props.reads\n    });\n  };\n\n  render() {\n    return <svg id=\"svg\" alt=\"Rendered sequence tube map visualization\" />;\n  }\n}\n\nTubeMap.propTypes = {\n  nodes: PropTypes.array.isRequired,\n  tracks: PropTypes.array.isRequired,\n  reads: PropTypes.array.isRequired \n};\n\nexport default TubeMap;\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport TubeMap from './TubeMap';\nimport { Container, Row, Alert } from 'reactstrap';\nimport * as tubeMap from '../util/tubemap';\nimport { dataOriginTypes } from '../enums';\n\nclass TubeMapContainer extends Component {\n  state = {\n    isLoading: true,\n    error: null\n  };\n\n  componentDidMount() {\n    this.getRemoteTubeMapData();\n  }\n\n  componentDidUpdate(prevProps) {\n    // TODO: this is the way the React docs say to make requests (do them when\n    // the component updates), but when we make a request we pop ourselves into\n    // a loading state and immediately do another update, which then means we\n    // have to mess around with deep comparison to see we don't need yet a\n    // third update. Is there a way to let React keep track of the fact that we\n    // aren't up to date with the requested state yet? \n    if (this.props.dataOrigin !== prevProps.dataOrigin) {\n      this.props.dataOrigin === dataOriginTypes.API\n        ? this.getRemoteTubeMapData()\n        : this.getExampleData();\n    } else {\n      if (JSON.stringify(this.props.fetchParams) !== JSON.stringify(prevProps.fetchParams)) {\n        // We need to compare the fetch parameters with stringification because\n        // they will get swapped out for a different object all the time, and we\n        // don't want to compare object identity. TODO: stringify isn't\n        // guaranteed to be stable so we can still make extra requests.\n        this.getRemoteTubeMapData();\n      } \n    }\n  }\n\n  render() {\n    const { isLoading, error } = this.state;\n\n    if (error) {\n      console.log(error);\n      const message = error.message ? error.message : error;\n      return (\n        <div id=\"tubeMapContainer\">\n          <Container>\n            <Row>\n              <Alert color=\"danger\">{message}</Alert>\n            </Row>\n          </Container>\n        </div>\n      );\n    }\n\n    if (isLoading) {\n      return (\n        <div id=\"tubeMapContainer\">\n          <Container>\n            <Row>\n              <div id=\"loaderContainer\">\n                <div id=\"loader\" />\n              </div>\n            </Row>\n          </Container>\n        </div>\n      );\n    }\n\n    return (\n      <div id=\"tubeMapContainer\">\n        <div id=\"tubeMapSVG\">\n          <TubeMap\n            nodes={this.state.nodes}\n            tracks={this.state.tracks}\n            reads={this.state.reads}\n          />\n        </div>\n      </div>\n    );\n  }\n\n  getRemoteTubeMapData = async () => {\n    this.setState({ isLoading: true, error: null });\n    try {\n      const response = await fetch(`${this.props.apiUrl}/getChunkedData`, {\n        method: 'POST',\n        headers: {\n          'Content-Type': 'application/json'\n        },\n        body: JSON.stringify(this.props.fetchParams)\n      });\n      const json = await response.json();\n      if (json.graph === undefined) {\n        // We did not get back a graph, only (possibly) an error.\n        const error = json.error || 'Fetching remote data returned error';\n        this.setState({ error: error, isLoading: false });\n      } else {\n        const nodes = tubeMap.vgExtractNodes(json.graph);\n        const tracks = tubeMap.vgExtractTracks(json.graph);\n        const reads = tubeMap.vgExtractReads(nodes, tracks, json.gam);\n        this.setState({\n          isLoading: false,\n          nodes,\n          tracks,\n          reads\n        });\n      }\n    } catch (error) {\n      this.setState({ error: error, isLoading: false });\n    }\n  };\n\n  getExampleData = async () => {\n    this.setState({ isLoading: true, error: null });\n    let nodes, tracks, reads;\n    const data = await import('../util/demo-data');\n    nodes = data.inputNodes;\n    switch (this.props.dataOrigin) {\n      case dataOriginTypes.EXAMPLE_1:\n        tracks = data.inputTracks1;\n        break;\n      case dataOriginTypes.EXAMPLE_2:\n        tracks = data.inputTracks2;\n        break;\n      case dataOriginTypes.EXAMPLE_3:\n        tracks = data.inputTracks3;\n        break;\n      case dataOriginTypes.EXAMPLE_4:\n        tracks = data.inputTracks4;\n        break;\n      case dataOriginTypes.EXAMPLE_5:\n        tracks = data.inputTracks5;\n        break;\n      case dataOriginTypes.EXAMPLE_6:\n        const vg = JSON.parse(data.k3138);\n        nodes = tubeMap.vgExtractNodes(vg);\n        tracks = tubeMap.vgExtractTracks(vg);\n        reads = tubeMap.vgExtractReads(\n          nodes,\n          tracks,\n          this.readsFromStringToArray(data.demoReads)\n        );\n        break;\n      default:\n        console.log('invalid data origin type');\n    }\n\n    this.setState({ isLoading: false, nodes, tracks, reads });\n  };\n\n  readsFromStringToArray = readsString => {\n    const lines = readsString.split('\\n');\n    const result = [];\n    lines.forEach(line => {\n      if (line.length > 0) {\n        result.push(JSON.parse(line));\n      }\n    });\n    return result;\n  };\n}\n\nTubeMapContainer.propTypes = {\n  apiUrl: PropTypes.string.isRequired,\n  dataOrigin: PropTypes.oneOf(Object.values(dataOriginTypes)).isRequired,\n  fetchParams: PropTypes.object.isRequired \n};\n\nexport default TubeMapContainer;\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport { Col, Label, Input, FormGroup } from 'reactstrap';\n\nconst colorMap = new Map([\n  ['colorful', 'plainColors'],\n  ['greyscale', 'greys'],\n  ['reds', 'reds'],\n  ['blues', 'blues'],\n  ['pale colors', 'lightColors']\n]);\n\nclass RadioRow extends Component {\n  onChange = event => {\n    this.props.setColorSetting(\n      this.props.trackType,\n      colorMap.get(event.target.value)\n    );\n  };\n\n  render() {\n    const colorRadios = Array.from(colorMap).map(([keyColor, valueColor]) => {\n      return (\n        <Col xs=\"auto\" key={keyColor}>\n          <FormGroup check>\n            <Label check>\n              <Input\n                type=\"radio\"\n                value={keyColor}\n                checked={this.props.color === valueColor}\n                onChange={this.onChange}\n              />\n              {keyColor}\n            </Label>\n          </FormGroup>\n        </Col>\n      );\n    });\n    return (\n      <FormGroup row className=\"mb-1\">\n        <Col sm=\"2\">{this.props.rowHeading}:</Col>\n        {colorRadios}\n      </FormGroup>\n    );\n  }\n}\n\nRadioRow.propTypes = {\n  color: PropTypes.string.isRequired,\n  rowHeading: PropTypes.string.isRequired,\n  setColorSetting: PropTypes.func.isRequired,\n  trackType: PropTypes.string.isRequired \n};\n\nexport default RadioRow;\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport {\n  Container,\n  Collapse,\n  CardBody,\n  Card,\n  CardHeader,\n  Form,\n  Label,\n  Input,\n  FormGroup\n} from 'reactstrap';\nimport RadioRow from './RadioRow';\n\nclass VisualizationOptions extends Component {\n  state = {\n    isOpenLegend: false,\n    isOpenVisualizationOptions: true\n  };\n\n  toggleLegend = e => {\n    this.setState({ isOpenLegend: !this.state.isOpenLegend });\n    e.preventDefault();\n  };\n\n  toggleVisOptions = e => {\n    this.setState({\n      isOpenVisualizationOptions: !this.state.isOpenVisualizationOptions\n    });\n    e.preventDefault();\n  };\n\n  handleMappingQualityCutoffChange = event => {\n    this.props.handleMappingQualityCutoffChange(event.target.value);\n  };\n\n  render() {\n    const { visOptions, toggleFlag } = this.props;\n    const mappingQualityOptions = Array.from(Array(61).keys()).map(i => {\n      return (\n        <option value={i} key={i}>\n          {i}\n        </option>\n      );\n    });\n    return (\n      <Container>\n        <div id=\"accordion\">\n          <Card>\n            <CardHeader id=\"legendCard\">\n              <h5 className=\"mb-0\">\n                <a href=\"#collapse\" onClick={this.toggleLegend}>\n                  Legend\n                </a>\n              </h5>\n            </CardHeader>\n            <Collapse isOpen={this.state.isOpenLegend}>\n              <CardBody>\n                <div id=\"legendDiv\" />\n              </CardBody>\n            </Collapse>\n          </Card>\n\n          <Card>\n            <CardHeader id=\"visOptionsCard\">\n              <h5 className=\"mb-0\">\n                <a href=\"#collapse\" onClick={this.toggleVisOptions}>\n                  Visualization Options\n                </a>\n              </h5>\n            </CardHeader>\n            <Collapse isOpen={this.state.isOpenVisualizationOptions}>\n              <CardBody>\n                <FormGroup>\n                  <h5>General</h5>\n                  <FormGroup check>\n                    <Label check>\n                      <Input\n                        type=\"checkbox\"\n                        checked={visOptions.removeRedundantNodes}\n                        onChange={() => toggleFlag('removeRedundantNodes')}\n                      />\n                      Remove redundant nodes\n                    </Label>\n                  </FormGroup>\n                  <FormGroup check>\n                    <Label check>\n                      <Input\n                        type=\"checkbox\"\n                        checked={visOptions.compressedView}\n                        onChange={() => toggleFlag('compressedView')}\n                      />\n                      Compressed view\n                    </Label>\n                  </FormGroup>\n                  <FormGroup check>\n                    <Label check>\n                      <Input\n                        type=\"checkbox\"\n                        checked={visOptions.transparentNodes}\n                        onChange={() => toggleFlag('transparentNodes')}\n                      />\n                      Fully transparent nodes\n                    </Label>\n                  </FormGroup>\n                </FormGroup>\n\n                <FormGroup>\n                  <h5>Sequence Reads</h5>\n                  <FormGroup check>\n                    <Label check>\n                      <Input\n                        type=\"checkbox\"\n                        checked={visOptions.showReads}\n                        onChange={() => toggleFlag('showReads')}\n                      />\n                      Show sequence reads\n                    </Label>\n                  </FormGroup>\n                  {visOptions.showReads && (\n                    <React.Fragment>\n                      <FormGroup check>\n                        <Label check>\n                          <Input\n                            type=\"checkbox\"\n                            checked={visOptions.showSoftClips}\n                            onChange={() => toggleFlag('showSoftClips')}\n                          />\n                          Show soft clips\n                        </Label>\n                      </FormGroup>\n                      <FormGroup check>\n                        <Label check>\n                          <Input\n                            type=\"checkbox\"\n                            checked={visOptions.colorReadsByMappingQuality}\n                            onChange={() =>\n                              toggleFlag('colorReadsByMappingQuality')\n                            }\n                          />\n                          Color reads by mapping quality\n                        </Label>\n                      </FormGroup>\n                      <Form inline>\n                        <Label className=\"mr-sm-2 \" for=\"dataSourceSelect\">\n                          Mapping Quality Cutoff:\n                        </Label>\n                        <Input\n                          type=\"select\"\n                          id=\"dataSourceSelect\"\n                          className=\"custom-select\"\n                          value={visOptions.mappingQualityCutoff}\n                          onChange={this.handleMappingQualityCutoffChange}\n                        >\n                          {mappingQualityOptions}\n                        </Input>\n                      </Form>\n                    </React.Fragment>\n                  )}\n                </FormGroup>\n\n                <h5>Colors</h5>\n                <Form>\n                  <RadioRow\n                    rowHeading=\"Haplotypes\"\n                    color={visOptions.haplotypeColors}\n                    trackType=\"haplotypeColors\"\n                    setColorSetting={this.props.setColorSetting}\n                  />\n                  {visOptions.showReads &&\n                    !visOptions.colorReadsByMappingQuality && (\n                      <React.Fragment>\n                        <RadioRow\n                          rowHeading=\"Reads (forward strand)\"\n                          color={visOptions.forwardReadColors}\n                          trackType=\"forwardReadColors\"\n                          setColorSetting={this.props.setColorSetting}\n                        />\n                        <RadioRow\n                          rowHeading=\"Reads (reverse strand)\"\n                          color={visOptions.reverseReadColors}\n                          trackType=\"reverseReadColors\"\n                          setColorSetting={this.props.setColorSetting}\n                        />\n                      </React.Fragment>\n                    )}\n                </Form>\n              </CardBody>\n            </Collapse>\n          </Card>\n        </div>\n      </Container>\n    );\n  }\n}\n\nVisualizationOptions.propTypes = {\n  handleMappingQualityCutoffChange: PropTypes.func.isRequired,\n  setColorSetting: PropTypes.func.isRequired\n};\n\nexport default VisualizationOptions;\n","import React, { Component } from 'react';\nimport PropTypes from 'prop-types';\nimport './App.css';\nimport HeaderForm from './components/HeaderForm';\nimport TubeMapContainer from './components/TubeMapContainer';\nimport CustomizationAccordion from './components/CustomizationAccordion';\nimport { dataOriginTypes } from './enums';\nimport * as tubeMap from './util/tubemap';\nimport config from './config.json';\n\nclass App extends Component {\n  constructor(props) {\n    super(props);\n    this.state = {\n      fetchParams: {\n        nodeID: '1',\n        distance: '100',\n        byNode: 'false',\n        xgFile: 'snp1kg-BRCA1.vg.xg',\n        gbwtFile: '',\n        gamFile: 'NA12878-BRCA1.sorted.gam',\n        anchorTrackName: '17',\n        dataPath: 'default'\n      },\n      dataOrigin: dataOriginTypes.API,\n      visOptions: {\n        removeRedundantNodes: true,\n        compressedView: false,\n        transparentNodes: false,\n        showReads: true,\n        showSoftClips: true,\n        haplotypeColors: 'greys',\n        forwardReadColors: 'reds',\n        reverseReadColors: 'blues',\n        colorReadsByMappingQuality: false,\n        mappingQualityCutoff: 0\n      }\n    };\n  }\n\n  componentDidUpdate() {\n    const { visOptions } = this.state;\n    visOptions.compressedView\n      ? tubeMap.setNodeWidthOption(1)\n      : tubeMap.setNodeWidthOption(0);\n    tubeMap.setMergeNodesFlag(visOptions.removeRedundantNodes);\n    tubeMap.setTransparentNodesFlag(visOptions.transparentNodes);\n    tubeMap.setShowReadsFlag(visOptions.showReads);\n    tubeMap.setSoftClipsFlag(visOptions.showSoftClips);\n    tubeMap.setColorSet('haplotypeColors', visOptions.haplotypeColors);\n    tubeMap.setColorSet('forwardReadColors', visOptions.forwardReadColors);\n    tubeMap.setColorSet('reverseReadColors', visOptions.reverseReadColors);\n    tubeMap.setColorReadsByMappingQualityFlag(\n      visOptions.colorReadsByMappingQuality\n    );\n    tubeMap.setMappingQualityCutoff(visOptions.mappingQualityCutoff);\n  }\n\n  setFetchParams = fetchParams => {\n    this.setState({\n      fetchParams: fetchParams,\n      dataOrigin: dataOriginTypes.API\n    });\n  };\n\n  toggleVisOptionFlag = flagName => {\n    this.setState(state => ({\n      visOptions: {\n        ...state.visOptions,\n        [flagName]: !state.visOptions[flagName]\n      }\n    }));\n  };\n\n  handleMappingQualityCutoffChange = value => {\n    this.setState(state => ({\n      visOptions: {\n        ...state.visOptions,\n        mappingQualityCutoff: value\n      }\n    }));\n  };\n\n  setColorSetting = (key, value) => {\n    this.setState(state => ({\n      visOptions: {\n        ...state.visOptions,\n        [key]: value\n      }\n    }));\n  };\n\n  setDataOrigin = dataOrigin => {\n    this.setState({ dataOrigin });\n  };\n\n  render() {\n    return (\n      <div>\n        <HeaderForm\n          setFetchParams={this.setFetchParams}\n          setDataOrigin={this.setDataOrigin}\n          setColorSetting={this.setColorSetting}\n          dataOrigin={this.state.dataOrigin}\n          apiUrl={this.props.apiUrl}\n        />\n        <TubeMapContainer\n          fetchParams={this.state.fetchParams}\n          dataOrigin={this.state.dataOrigin}\n          apiUrl={this.props.apiUrl}\n        />\n        <CustomizationAccordion\n          visOptions={this.state.visOptions}\n          toggleFlag={this.toggleVisOptionFlag}\n          handleMappingQualityCutoffChange={\n            this.handleMappingQualityCutoffChange\n          }\n          setColorSetting={this.setColorSetting}\n        />\n      </div>\n    );\n  }\n}\n\nApp.propTypes = {\n  apiUrl: PropTypes.string\n}\n\nApp.defaultProps = {\n  // Backend the whole app will hit against. Usually should be picked up from\n  // the config or the browser, but needs to be swapped out in the fake\n  // browser testing environment to point to a real testing backend.\n  // Note that host includes the port.\n  apiUrl: (config.BACKEND_URL || `http://${window.location.host}`) + '/api/v0'\n};\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport 'bootstrap/dist/css/bootstrap.css';\nimport App from './App';\n\nReactDOM.render(<App />, document.getElementById('root'));\n"],"sourceRoot":""}